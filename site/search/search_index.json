{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Red-Office-Google-Integration Documentation","text":"<p>Red-Office-Google-Integration is a comprehensive package designed to simplify integration with Google APIs, specifically Calendar, Sheets, and Gmail. Originally envisioned as three separate packages, the project now offers all functionalities bundled into one, providing users with a seamless experience.</p>"},{"location":"#features-overview","title":"Features Overview","text":"<ul> <li>Calendar: Create, list, get, and delete events in Google Calendar. Designed for extensibility to accommodate future feature additions.</li> <li>Sheets:<ul> <li>Insert CSV content in a defined range.</li> <li>Replace a defined range with CSV content.</li> <li>Get full worksheet data (and from specified ranges).</li> <li>Replace a single cell.</li> <li>Output data in JSON or CSV format.</li> </ul> </li> <li>Gmail:<ul> <li>Get emails by label, recipient, or 'has attachment' status.</li> <li>Archive and label emails by ID.</li> <li>Create draft emails, with the ability to attach files.</li> <li>Download attachments by email ID to a specified path.</li> </ul> </li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>The package is designed for ease of use, handling credentials internally. It can be utilized through a single file with a Command Line Interface (CLI), making integration straightforward and efficient.</p>"},{"location":"CLI_Initialize_credentials/","title":"Initialize Credentials","text":""},{"location":"CLI_Initialize_credentials/#red_office_google_integration.CLI_handler.credentials_management_cli.initialize_credentials.init_cred","title":"<code>init_cred(cred, output, key)</code>","text":"<p>Encrypts the credentials using a fernet key and saves the file.</p> <p>Parameters:</p> Name Type Description Default <code>cred</code> <code>str</code> <p>Path to the credential file | in string.</p> required <code>output</code> <code>(filepath, optional)</code> <p>Path to the output directory where the encrypted file will be saved.</p> required <code>key</code> <code>(str, optional)</code> <p>Path to the key file used for encryption (fernet key by default).</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>red_office_google_integration/CLI_handler/credentials_management_cli/initialize_credentials.py</code> <pre><code>@click.command(help=\"Encrypts the credentials and saves the file.\")\n@click.argument('cred', type=str, required=True)\n@click.option('-o', '--output', type=click.Path(writable=True, resolve_path=True), help='Output directory to save key')\n@click.option('-k', '--key', type=click.STRING, help='Custom key in string')\ndef init_cred(cred, output, key: str) -&gt; None:\n    \"\"\"\n    Encrypts the credentials using a fernet key and saves the file.\n\n    Args:\n        cred (str): Path to the credential file | in string.\n        output (filepath,optional): Path to the output directory where the encrypted file will be saved.\n        key (str,optional): Path to the key file used for encryption (fernet key by default).\n\n    Returns:\n        None\n    \"\"\"\n    # Load cred from file or string\n    if os.path.isfile(cred):\n        with open(cred, 'r') as f:\n            cred = f.read()\n    else:\n        try:\n            cred = json.loads(cred)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n    if key:\n        print(key)\n        result = InitializeCredential(\n            cred, setting.DEFAULT_CREDENTIAL_FILE_NAME, key.encode())\n    else:\n        result = InitializeCredential(\n            cred, setting.DEFAULT_CREDENTIAL_FILE_NAME)\n\n    result.initialize()\n\n    result = {\n        'status': result.status,\n        'key': result.get_key().decode()\n    }\n\n    if output:\n        with open(output, 'w') as f:\n            json.dump(result, f)\n        click.echo(json.dumps(result))\n    else:\n        click.echo(json.dumps(result, indent=2))\n</code></pre>"},{"location":"CLI_calendar_events/","title":"Calendar Events","text":"<p>Module for handling Google Calendar events.</p> <p>This module provides functionalities to perform actions on Google Calendar events, such as creating, deleting, listing, and getting events.</p> Commands <ul> <li>calendar: Group command for performing actions on Google Calendar events.</li> <li>event: Command to perform actions on Google Calendar events.</li> </ul> Usage <ul> <li>calendar: Group command to interact with Google Calendar events.</li> <li>event: Command to execute actions like create, delete, list, or get on Google Calendar events.</li> </ul> Example Usage <p>To create an event: <pre><code>    $ python main.py calander event create path_to_payload.json --output output_directory\n</code></pre> To delete an event: <pre><code>    $ python main.py calander event delete path_to_payload.json\n</code></pre> To list events: <pre><code>    $ python main.py calander event list path_to_payload.json\n</code></pre> To get an event:</p> <p><pre><code>    $ python main.py calander event get path_to_payload.json\n</code></pre> <code>path_to_payload or JSON String</code></p> <p>Parameters:     - action: The action to perform. Must be one of 'create', 'delete', 'list', 'get'.     - payload: Path to a JSON file containing the payload or a JSON string representing the payload.     - output: Optional parameter to specify an output directory for the result.</p> Note <p>The payload must contain necessary information like 'key' and 'calendarId' for the actions to be executed successfully.</p>"},{"location":"CLI_calendar_events/#red_office_google_integration.CLI_handler.calendar.events.event","title":"<code>event(action, payload, output)</code>","text":"<p>ACTION: The action to perform. Must be one of 'create', 'delete', 'list', 'get'. PAYLOAD: Path to a JSON file containing the payload or a JSON string representing the payload. Use '--output' to specify an output directory.</p> Source code in <code>red_office_google_integration/CLI_handler/calendar/events.py</code> <pre><code>@click.command(help=\"Perform actions on Google Calendar events.\")\n@click.argument('action', type=click.Choice(['create', 'delete', 'list', 'get']))\n@click.argument('payload', type=str, required=True)\n@click.option('-o', '--output', type=click.Path(writable=True, resolve_path=True), help='Output directory')\ndef event(action, payload, output):\n    \"\"\"\n    ACTION: The action to perform. Must be one of 'create', 'delete', 'list', 'get'.\n    PAYLOAD: Path to a JSON file containing the payload or a JSON string representing the payload.\n    Use '--output' to specify an output directory.\n    \"\"\"\n    # Load payload from file or string\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    # Validate payload\n    key = payload_data.get('key')\n    calendar_id = payload_data.get('calendarId')\n    if not key:\n        raise click.ClickException(\n            \"Key not found! Please specify the key in the payload.\")\n    if not calendar_id:\n        raise click.ClickException(\n            \"CalendarId not found! Please specify the calendarId in the payload.\")\n\n    # Initialize CalendarEvent event\n    event = CalendarEvent(key.encode())\n\n    # Perform action based on user input\n    if action == 'create':\n        if 'event_data' in payload_data:\n            event_data = payload_data.get('event_data')\n            result = event.create_event(calendar_id, event_data)\n        else:\n            raise click.ClickException('Event_data not found in the payload.')\n    elif action == 'delete':\n        if 'eventId' in payload_data:\n            optional_parameter = payload_data.get('optional_parameter', {})\n            result = event.delete_event(\n                calendar_id, payload_data['eventId'], **optional_parameter)\n        else:\n            raise click.ClickException('EventId not found in the payload.')\n    elif action == 'list':\n        optional_parameter = payload_data.get('optional_parameter', {})\n        result = event.list_event(calendar_id, optional_parameter)\n    elif action == 'get':\n        if 'eventId' in payload_data:\n            optional_parameter = payload_data.get('optional_parameter', {})\n            result = event.get_event(\n                calendar_id, payload_data['eventId'], **optional_parameter)\n        else:\n            raise click.ClickException('EventId not found in the payload.')\n    else:\n        raise click.ClickException('Event operation type not valid!')\n    # Output result\n    if output:\n        with open(output, 'w') as f:\n            json.dump(result, f)\n        click.echo(json.dumps(result))\n    else:\n        click.echo(json.dumps(result, indent=2))\n</code></pre>"},{"location":"CLI_gmail/","title":"Gmail","text":""},{"location":"CLI_gmail/#red_office_google_integration.CLI_handler.gmail.gmail_cli.create_draft","title":"<code>create_draft(payload, attachment)</code>","text":"<p>Create a draft email in Gmail using the provided payload.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>Path to a JSON file or a JSON string containing the email payload.</p> required <code>attachment</code> <code>list</code> <p>List of paths to attachment files to be included in the email draft.</p> required <p>Raises:</p> Type Description <code>BadParameter</code> <p>If the payload is not a valid JSON string or file path.</p> Source code in <code>red_office_google_integration/CLI_handler/gmail/gmail_cli.py</code> <pre><code>@click.command(help=\"Create Draft Email\")\n@click.argument('payload', type=str, required=True)\n@click.option('-a', '--attachment', multiple=True, type=click.Path(writable=True, resolve_path=True), help='attachment file')\ndef create_draft(payload, attachment):\n    \"\"\"\n        Create a draft email in Gmail using the provided payload.\n\n        Args:\n            payload (str): Path to a JSON file or a JSON string containing the email payload.\n            attachment (list): List of paths to attachment files to be included in the email draft.\n\n        Raises:\n            click.BadParameter: If the payload is not a valid JSON string or file path.\n\n    \"\"\"\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    key = payload_data.get('key')\n    header = payload_data.get('header')\n    body = payload_data.get('body')\n    subtype = payload_data.get('subtype', \"plain\")\n    userid = payload_data.get('userId', 'me')\n\n    email_message = EmailCreation(\n        header, body, subtype)  # Creating email payload\n    if attachment:\n        for a in attachment:\n            if os.path.isfile(a):\n                email_message.add_file(a)\n            else:\n                raise click.BadParameter(f\"file dosent exist {a}\")\n\n    gmail = Gmail(key.encode())\n\n    result = gmail.create_draft(email_message, userid)\n    print(json.dumps(result, indent=2))\n</code></pre>"},{"location":"CLI_gmail/#red_office_google_integration.CLI_handler.gmail.gmail_cli.download_attachment","title":"<code>download_attachment(payload, output)</code>","text":"<p>Download an attachment from an email.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>Path to a JSON file or a JSON string containing the email data.</p> required <code>output</code> <code>str</code> <p>Path to the output directory.</p> required Source code in <code>red_office_google_integration/CLI_handler/gmail/gmail_cli.py</code> <pre><code>@click.command(help=\"Download Attachment\")\n@click.argument('payload', type=str, required=True)\n@click.option('-o', '--output', type=click.Path(file_okay=False, dir_okay=True, writable=True, resolve_path=True), help='Output directory', required=True)\ndef download_attachment(payload, output):\n    \"\"\"\n        Download an attachment from an email.\n\n        Args:\n            payload (str): Path to a JSON file or a JSON string containing the email data.\n            output (str): Path to the output directory.\n    \"\"\"\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    print(output)\n\n    key = payload_data.get('key')\n    message_id = payload_data.get('messageId')\n    user_id = payload_data.get('userId', 'me')\n    optionals = payload_data.get('optionals', {})\n\n    mail = Gmail(key.encode())\n\n    message = mail.get_email(message_id, user_id, **optionals)\n\n    for part in message['payload']['parts']:\n        data: str\n        if part['filename']:\n            if 'data' in part['body']:\n                data = part['data']['body']\n            else:\n                attachment_id = part['body']['attachmentId']\n                data = mail.get_attachment_encoded(\n                    message_id, attachment_id)\n            filename = part['filename']\n            file_data = base64.urlsafe_b64decode(data.encode())\n            save_attachment(output, filename, file_data)\n            print(filename)\n</code></pre>"},{"location":"CLI_gmail/#red_office_google_integration.CLI_handler.gmail.gmail_cli.get_email","title":"<code>get_email(payload)</code>","text":"<p>Get an email.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>Path to a JSON file or a JSON string containing the email data.</p> required <p>Returns:None</p> Source code in <code>red_office_google_integration/CLI_handler/gmail/gmail_cli.py</code> <pre><code>@click.command(help=\"Get email\")\n@click.argument('payload', type=str, required=True)\ndef get_email(payload):\n    \"\"\"\n        Get an email.\n\n        Args:\n            payload (str): Path to a JSON file or a JSON string containing the email data.\n\n        Returns:None\n    \"\"\"\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    key = payload_data.get('key')\n    message_id = payload_data.get('messageId')\n    user_id = payload_data.get('userId', 'me')\n    optionals = payload_data.get('optionals', {})\n\n    mail = Gmail(key.encode())\n    result = mail.get_email(message_id, user_id, **optionals)\n    print(json.dumps(result, indent=2))\n</code></pre>"},{"location":"CLI_gmail/#red_office_google_integration.CLI_handler.gmail.gmail_cli.get_email_list","title":"<code>get_email_list(payload)</code>","text":"<p>List emails based on query parameters.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>Path to a JSON file or a JSON string containing the email data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The list of emails that match the query parameters.</p> Source code in <code>red_office_google_integration/CLI_handler/gmail/gmail_cli.py</code> <pre><code>@click.command(help=\"List email through query parameter\")\n@click.argument('payload', type=str, required=True)\ndef get_email_list(payload):\n    \"\"\"\n    List emails based on query parameters.\n\n    Args:\n        payload (str): Path to a JSON file or a JSON string containing the email data.\n\n    Returns:\n        dict: The list of emails that match the query parameters.\n    \"\"\"\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    key = payload_data.get('key')\n    query = payload_data.get('query', '')\n    user_id = payload_data.get('userId', 'me')\n    optionals = payload_data.get('optionals', {})\n\n    mail = Gmail(key.encode())\n    result = mail.get_email_list(query, user_id, **optionals)\n    print(json.dumps(result, indent=2))\n</code></pre>"},{"location":"CLI_gmail/#red_office_google_integration.CLI_handler.gmail.gmail_cli.save_attachment","title":"<code>save_attachment(directory_name, filename, data)</code>","text":"<p>Save an attachment to a file.</p> <p>Parameters:</p> Name Type Description Default <code>directory_name</code> <code>str</code> <p>Path to the output directory.</p> required <code>filename</code> <code>str</code> <p>Name of the file to save.</p> required <code>data</code> <code>bytes</code> <p>Attachment data.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>red_office_google_integration/CLI_handler/gmail/gmail_cli.py</code> <pre><code>@handle_exception\ndef save_attachment(directory_name, filename, data: bytes):\n    \"\"\"\n        Save an attachment to a file.\n\n        Args:\n            directory_name (str): Path to the output directory.\n            filename (str): Name of the file to save.\n            data (bytes): Attachment data.\n\n        Returns:\n            None\n    \"\"\"\n    with open(os.path.join(directory_name, filename), 'wb') as f:\n        f.write(data)\n</code></pre>"},{"location":"CLI_spreadsheet/","title":"Spreadsheet","text":""},{"location":"CLI_spreadsheet/#red_office_google_integration.CLI_handler.spreadsheet.spreadsheetCLI.append_data","title":"<code>append_data(payload)</code>","text":"<p>Appends values to a specified range in a Google Sheets spreadsheet.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>Path to a JSON file or a JSON string containing the request payload.</p> required Source code in <code>red_office_google_integration/CLI_handler/spreadsheet/spreadsheetCLI.py</code> <pre><code>@click.command(help=\"Append values to spreadsheet\")\n@click.argument('payload', type=str, required=True)\ndef append_data(payload):\n    \"\"\"\n        Appends values to a specified range in a Google Sheets spreadsheet.\n\n        Args:\n            payload (str): Path to a JSON file or a JSON string containing the request payload.\n    \"\"\"\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    key = payload_data.get('key')\n    spreadsheetId = payload_data.get('spreadsheetId')\n    valueInputOption = payload_data.get('valueInputOption')\n    range = payload_data.get('range')\n    values = payload_data.get('values')\n    optionals = payload_data.get('optionals', {})\n\n    spreadsheet = SpreadSheet(key.encode())\n    result = spreadsheet.append_data(\n        spreadsheetId, range, valueInputOption, values, **optionals)\n\n    print(json.dumps(result, indent=2))\n</code></pre>"},{"location":"CLI_spreadsheet/#red_office_google_integration.CLI_handler.spreadsheet.spreadsheetCLI.batch_update_values","title":"<code>batch_update_values(payload)</code>","text":"<p>Updates values in multiple specified ranges in a Google Sheets spreadsheet.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>Path to a JSON file or a JSON string containing the request payload.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>red_office_google_integration/CLI_handler/spreadsheet/spreadsheetCLI.py</code> <pre><code>@click.command(help=\"update_values to multiple specifed range in spreadsheet\")\n@click.argument('payload', type=str, required=True)\ndef batch_update_values(payload):\n    \"\"\"\n        Updates values in multiple specified ranges in a Google Sheets spreadsheet.\n\n        Args:\n            payload (str): Path to a JSON file or a JSON string containing the request payload.\n\n        Returns:\n            None\n    \"\"\"\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    key = payload_data.get('key')\n    spreadsheetId = payload_data.get('spreadsheetId')\n    data = payload_data.get('data')\n    valueInputOption = payload_data.get('valueInputOption')\n    optionals = payload_data.get('optionals', {})\n\n    spreadsheet = SpreadSheet(key.encode())\n    result = spreadsheet.batch_update_values(\n        spreadsheetId, valueInputOption, data, **optionals)\n    print(json.dumps(result, indent=2))\n</code></pre>"},{"location":"CLI_spreadsheet/#red_office_google_integration.CLI_handler.spreadsheet.spreadsheetCLI.get_batch_data","title":"<code>get_batch_data(payload, output)</code>","text":"<p>Retrieves data from multiple specified ranges in a Google Sheets spreadsheet.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>Path to a JSON file or a JSON string containing the request payload.</p> required <code>output</code> <code>str</code> <p>Path to the output file where the retrieved data will be saved.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>red_office_google_integration/CLI_handler/spreadsheet/spreadsheetCLI.py</code> <pre><code>@click.command(help=\"Retrieves data from a multiple specified ranges in a Google Sheets spreadsheet.\")\n@click.argument('payload', type=str, required=True)\n@click.option('-o', '--output', type=click.Path(writable=True, resolve_path=True), help='Output directory')\ndef get_batch_data(payload, output):\n    \"\"\"\n        Retrieves data from multiple specified ranges in a Google Sheets spreadsheet.\n\n        Args:\n            payload (str): Path to a JSON file or a JSON string containing the request payload.\n            output (str): Path to the output file where the retrieved data will be saved.\n\n        Returns:\n            None\n    \"\"\"\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    key = payload_data.get('key')\n    spreadsheetId = payload_data.get('spreadsheetId')\n    ranges = payload_data.get('ranges')\n    optionals = payload_data.get('optionals', {})\n    spreadsheet = SpreadSheet(key.encode())\n\n    res = spreadsheet.get_batch_data(spreadsheetId, ranges, **optionals)\n    print(json.dumps(res, indent=2))\n\n    if output:\n        save_to_file(res, output)\n</code></pre>"},{"location":"CLI_spreadsheet/#red_office_google_integration.CLI_handler.spreadsheet.spreadsheetCLI.get_data","title":"<code>get_data(payload, output)</code>","text":"<p>Retrieves data from a specified range in a Google Sheets spreadsheet.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>Path to a JSON file or a JSON string containing the request payload.</p> required <code>output</code> <code>str</code> <p>Path to the output file where the retrieved data will be saved.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>red_office_google_integration/CLI_handler/spreadsheet/spreadsheetCLI.py</code> <pre><code>@click.command(help=\"Retrieves data from a specified range in a Google Sheets spreadsheet.\")\n@click.argument('payload', type=str, required=True)\n@click.option('-o', '--output', type=click.Path(writable=True, resolve_path=True), help='Output directory')\ndef get_data(payload, output):\n    \"\"\"\n        Retrieves data from a specified range in a Google Sheets spreadsheet.\n\n        Args:\n            payload (str): Path to a JSON file or a JSON string containing the request payload.\n            output (str): Path to the output file where the retrieved data will be saved.\n\n        Returns:\n            None\n    \"\"\"\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    key = payload_data.get('key')\n    spreadsheetId = payload_data.get('spreadsheetId')\n    range = payload_data.get('range')\n    optionals = payload_data.get('optionals', {})\n    spreadsheet = SpreadSheet(key.encode())\n\n    res = spreadsheet.get_data(spreadsheetId, range, **optionals)\n    print(json.dumps(res, indent=2))\n\n    if output:\n        save_to_file(res, output)\n</code></pre>"},{"location":"CLI_spreadsheet/#red_office_google_integration.CLI_handler.spreadsheet.spreadsheetCLI.save_to_file","title":"<code>save_to_file(data, filename)</code>","text":"<p>Saves data to a file in CSV or JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data to be saved.</p> required <code>filename</code> <code>str</code> <p>The path to the file where the data will be saved.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>red_office_google_integration/CLI_handler/spreadsheet/spreadsheetCLI.py</code> <pre><code>@handle_exception\ndef save_to_file(data, filename):\n    \"\"\"\n    Saves data to a file in CSV or JSON format.\n\n    Args:\n        data (dict): The data to be saved.\n        filename (str): The path to the file where the data will be saved.\n\n    Returns:\n        None\n    \"\"\"\n    df = pd.DataFrame(data)\n    _, file_extension = os.path.splitext(filename)\n    if file_extension.lower() == '.csv':\n        df.to_csv(filename, index=False, header=False)\n    elif file_extension.lower() == '.json':\n        df.to_json(filename, indent=2, orient='records')\n    else:\n        raise click.BadParameter(\n            \"Output file must be either a CSV or JSON file. Unable to save\")\n</code></pre>"},{"location":"CLI_spreadsheet/#red_office_google_integration.CLI_handler.spreadsheet.spreadsheetCLI.update_values","title":"<code>update_values(payload)</code>","text":"<p>Updates values in a specified range in a Google Sheets spreadsheet.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>Path to a JSON file or a JSON string containing the request payload.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>red_office_google_integration/CLI_handler/spreadsheet/spreadsheetCLI.py</code> <pre><code>@click.command(help=\"update_values to specifed range in spreadsheet\")\n@click.argument('payload', type=str, required=True)\ndef update_values(payload):\n    \"\"\"\n        Updates values in a specified range in a Google Sheets spreadsheet.\n\n        Args:\n            payload (str): Path to a JSON file or a JSON string containing the request payload.\n\n        Returns:\n            None\n    \"\"\"\n    if os.path.isfile(payload):\n        with open(payload, 'r') as f:\n            payload_data = json.load(f)\n    else:\n        try:\n            payload_data = json.loads(payload)\n        except json.JSONDecodeError:\n            raise click.BadParameter(\n                'Payload must be a valid JSON string or a path to a JSON file.')\n\n    key = payload_data.get('key')\n    spreadsheetId = payload_data.get('spreadsheetId')\n    valueInputOption = payload_data.get('valueInputOption')\n    range = payload_data.get('range')\n    values = payload_data.get('values')\n    optionals = payload_data.get('optionals', {})\n\n    spreadsheet = SpreadSheet(key.encode())\n    result = spreadsheet.update_values(\n        spreadsheetId, range, valueInputOption, values, **optionals)\n\n    print(json.dumps(result, indent=2))\n</code></pre>"},{"location":"calendar-events/","title":"Events","text":"<p>TODO:  - unit testing</p> <ul> <li>optional:<ul> <li>Implement update_event()</li> <li>patch_event() methods. NOTE: Features that can be added:</li> <li>find and replace</li> </ul> </li> </ul>"},{"location":"calendar-events/#red_office_google_integration.calendar.events.events.CalendarEvent","title":"<code>CalendarEvent</code>","text":"<p>A class for handling Google Calendar events.</p> <p>Methods: - create_event() - delete_event() - list_event() - get_event()</p> Source code in <code>red_office_google_integration/calendar/events/events.py</code> <pre><code>class CalendarEvent:\n    '''\n    A class for handling Google Calendar events.\n\n    Methods:\n    - create_event()\n    - delete_event()\n    - list_event()\n    - get_event()\n    '''\n\n    def __init__(self, key: bytes):\n        '''\n        Initialize the CalendarEvent class.\n\n        Args:\n            key (bytes): The key used for authentication.\n        '''\n        self.__key = key\n        self.service = self.__build_service()\n\n    @handle_exception\n    def __build_service(self):\n        '''\n        Build and return the Google Calendar service.\n\n        Returns:\n            (cred): The Google Calendar service.\n        '''\n        cred = GoogleCredentialService(\n            self.__key, setting.SCOPE_CALENDAR, setting.FILE_NAME_CALENDAR_TOKEN, setting.FILE_NAME_CALENDAR_CREDENTIAL).get_service()\n        return build(\"calendar\", \"v3\", credentials=cred)\n\n    @handle_exception\n    def create_event(self, calendarId: str, event_data: dict[str, Any]) -&gt; dict:\n        '''\n            Create a new event in the specified calendar.\n\n            Args:\n                calendarId (str): The ID of the calendar in which to create the event.\n                event_data (dict): A dictionary containing the details of the event.\n                    Find more details on event data format: \n                    [Create events](https://developers.google.com/calendar/api/guides/create-events)\n\n            Returns:\n                dict: The created event data.\n\n            Example payload:\n                ```\n                calendarId = 'primary'\n                event_data = {\n                    'summary': 'Google I/O 2015',\n                    'location': '800 Howard St., San Francisco, CA 94103',\n                    'description': 'A chance to hear more about Google developer products.',\n                    'start': {\n                        'dateTime': '2015-05-28T09:00:00-07:00',\n                        'timeZone': 'America/Los_Angeles',\n                    },\n                    'end': {\n                        'dateTime': '2015-05-28T17:00:00-07:00',\n                        'timeZone': 'America/Los_Angeles',\n                    },\n                    'recurrence': [\n                        'RRULE:FREQ=DAILY;COUNT=2'\n                    ],\n                    'attendees': [\n                        {'email': 'lpage@example.com'},\n                        {'email': 'sbrin@example.com'},\n                    ],\n                    'reminders': {\n                        'useDefault': False,\n                        'overrides': [\n                            {'method': 'email', 'minutes': 24 * 60},\n                            {'method': 'popup', 'minutes': 10},\n                        ],\n                    },\n                }\n                event = CalendarEvent(key)\n                data = event.create_event(calendarId, event_data)\n                ```\n\n        '''\n        event = self.service.events().insert(\n            calendarId=calendarId, body=event_data).execute()\n        logger.info(f\"Success: {event}\")\n        return event\n\n    @handle_exception\n    def delete_event(self, calendarId: str, eventId: str, **kwargs) -&gt; dict:\n        '''\n        Delete an event from the specified calendar.\n\n        Args:\n            calendarId (str): The ID of the calendar from which to delete the event.\n            eventId (str): The ID of the event to delete.\n\n        Returns:\n            dict: A status message indicating the deletion was successful.\n\n        ## example\n\n            event = GoogleCredentialService().delete_event(calendarId,eventId)\n\n            ### Example with Optional query parameters\n            ```\n            optional_parameter = {\n                'sendUpdates' : 'all'\n            }\n            calendarId = 'primary'\n            eventId = 'eventId'\n\n            event = CalendarEvent(key)\n            data = event.delete_event(calendarId,eventId,optional_parameter)\n            ```\n\n\n        '''\n        event = self.service.events().delete(calendarId=calendarId,\n                                             eventId=eventId, **kwargs).execute()\n        logger.warning(f'Event with ID {eventId} deleted Successfully.')\n\n        return {'status': 'Deleted', 'event_id': eventId}\n\n    @handle_exception\n    def list_event(self, calendarId: str, optional_parameter: dict) -&gt; dict:\n        '''\n        List events from the specified calendar.\n\n        Args:\n            calendarId (str): The ID of the calendar from which to list events.\n            optional_parameter (dict): Optional parameters for listing events. Refer to the\n                [Events: list documentation](https://developers.google.com/calendar/api/v3/reference/events/list)\n                for details on available parameters.\n\n        Returns:\n            dict: The list of events.\n\n        Example:\n            ```\n            # Example without optional parameters\n            event = GoogleCredentialService(key).list_event(calendarId, {})\n\n            # Example with optional query parameters\n            optional_parameter = {\n                'maxResults': 2,\n                # Add more optional parameters as needed\n            }\n            event = CalendarEvent(key)\n            data = event.list_event(calendarId, optional_parameter)\n            ```\n        '''\n        events = self.service.events().list(\n            calendarId=calendarId, **optional_parameter).execute()\n        return events\n\n    @handle_exception\n    def get_event(self, calendarId: str, eventId: str, **kwargs) -&gt; dict:\n        '''\n        Get details of a specific event from the specified calendar.\n\n        Args:\n            calendarId (str): The ID of the calendar containing the event.\n            eventId (str): The ID of the event to retrieve.\n            **kwargs (**kwarg): Optional keyword arguments for additional parameters. Refer to the\n                [Events: get documentation](https://developers.google.com/calendar/api/v3/reference/events/get)\n                for details on available parameters.\n\n        Returns:\n            (dict): The event details.\n\n        Example:\n            ```\n            event = CalendarEvent(key)\n            data = event.get_event(calendarId, eventId)\n            ```\n        '''\n        event = self.service.events().get(calendarId=calendarId,\n                                          eventId=eventId, **kwargs).execute()\n        return event\n</code></pre>"},{"location":"calendar-events/#red_office_google_integration.calendar.events.events.CalendarEvent.__build_service","title":"<code>__build_service()</code>","text":"<p>Build and return the Google Calendar service.</p> <p>Returns:</p> Type Description <code>cred</code> <p>The Google Calendar service.</p> Source code in <code>red_office_google_integration/calendar/events/events.py</code> <pre><code>@handle_exception\ndef __build_service(self):\n    '''\n    Build and return the Google Calendar service.\n\n    Returns:\n        (cred): The Google Calendar service.\n    '''\n    cred = GoogleCredentialService(\n        self.__key, setting.SCOPE_CALENDAR, setting.FILE_NAME_CALENDAR_TOKEN, setting.FILE_NAME_CALENDAR_CREDENTIAL).get_service()\n    return build(\"calendar\", \"v3\", credentials=cred)\n</code></pre>"},{"location":"calendar-events/#red_office_google_integration.calendar.events.events.CalendarEvent.__init__","title":"<code>__init__(key)</code>","text":"<p>Initialize the CalendarEvent class.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The key used for authentication.</p> required Source code in <code>red_office_google_integration/calendar/events/events.py</code> <pre><code>def __init__(self, key: bytes):\n    '''\n    Initialize the CalendarEvent class.\n\n    Args:\n        key (bytes): The key used for authentication.\n    '''\n    self.__key = key\n    self.service = self.__build_service()\n</code></pre>"},{"location":"calendar-events/#red_office_google_integration.calendar.events.events.CalendarEvent.create_event","title":"<code>create_event(calendarId, event_data)</code>","text":"<p>Create a new event in the specified calendar.</p> <p>Parameters:</p> Name Type Description Default <code>calendarId</code> <code>str</code> <p>The ID of the calendar in which to create the event.</p> required <code>event_data</code> <code>dict</code> <p>A dictionary containing the details of the event. Find more details on event data format:  Create events</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The created event data.</p> Example payload <pre><code>calendarId = 'primary'\nevent_data = {\n    'summary': 'Google I/O 2015',\n    'location': '800 Howard St., San Francisco, CA 94103',\n    'description': 'A chance to hear more about Google developer products.',\n    'start': {\n        'dateTime': '2015-05-28T09:00:00-07:00',\n        'timeZone': 'America/Los_Angeles',\n    },\n    'end': {\n        'dateTime': '2015-05-28T17:00:00-07:00',\n        'timeZone': 'America/Los_Angeles',\n    },\n    'recurrence': [\n        'RRULE:FREQ=DAILY;COUNT=2'\n    ],\n    'attendees': [\n        {'email': 'lpage@example.com'},\n        {'email': 'sbrin@example.com'},\n    ],\n    'reminders': {\n        'useDefault': False,\n        'overrides': [\n            {'method': 'email', 'minutes': 24 * 60},\n            {'method': 'popup', 'minutes': 10},\n        ],\n    },\n}\nevent = CalendarEvent(key)\ndata = event.create_event(calendarId, event_data)\n</code></pre> Source code in <code>red_office_google_integration/calendar/events/events.py</code> <pre><code>@handle_exception\ndef create_event(self, calendarId: str, event_data: dict[str, Any]) -&gt; dict:\n    '''\n        Create a new event in the specified calendar.\n\n        Args:\n            calendarId (str): The ID of the calendar in which to create the event.\n            event_data (dict): A dictionary containing the details of the event.\n                Find more details on event data format: \n                [Create events](https://developers.google.com/calendar/api/guides/create-events)\n\n        Returns:\n            dict: The created event data.\n\n        Example payload:\n            ```\n            calendarId = 'primary'\n            event_data = {\n                'summary': 'Google I/O 2015',\n                'location': '800 Howard St., San Francisco, CA 94103',\n                'description': 'A chance to hear more about Google developer products.',\n                'start': {\n                    'dateTime': '2015-05-28T09:00:00-07:00',\n                    'timeZone': 'America/Los_Angeles',\n                },\n                'end': {\n                    'dateTime': '2015-05-28T17:00:00-07:00',\n                    'timeZone': 'America/Los_Angeles',\n                },\n                'recurrence': [\n                    'RRULE:FREQ=DAILY;COUNT=2'\n                ],\n                'attendees': [\n                    {'email': 'lpage@example.com'},\n                    {'email': 'sbrin@example.com'},\n                ],\n                'reminders': {\n                    'useDefault': False,\n                    'overrides': [\n                        {'method': 'email', 'minutes': 24 * 60},\n                        {'method': 'popup', 'minutes': 10},\n                    ],\n                },\n            }\n            event = CalendarEvent(key)\n            data = event.create_event(calendarId, event_data)\n            ```\n\n    '''\n    event = self.service.events().insert(\n        calendarId=calendarId, body=event_data).execute()\n    logger.info(f\"Success: {event}\")\n    return event\n</code></pre>"},{"location":"calendar-events/#red_office_google_integration.calendar.events.events.CalendarEvent.delete_event","title":"<code>delete_event(calendarId, eventId, **kwargs)</code>","text":"<p>Delete an event from the specified calendar.</p> <p>Parameters:</p> Name Type Description Default <code>calendarId</code> <code>str</code> <p>The ID of the calendar from which to delete the event.</p> required <code>eventId</code> <code>str</code> <p>The ID of the event to delete.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A status message indicating the deletion was successful.</p>"},{"location":"calendar-events/#red_office_google_integration.calendar.events.events.CalendarEvent.delete_event--example","title":"example","text":"<pre><code>event = GoogleCredentialService().delete_event(calendarId,eventId)\n\n### Example with Optional query parameters\n```\noptional_parameter = {\n    'sendUpdates' : 'all'\n}\ncalendarId = 'primary'\neventId = 'eventId'\n\nevent = CalendarEvent(key)\ndata = event.delete_event(calendarId,eventId,optional_parameter)\n```\n</code></pre> Source code in <code>red_office_google_integration/calendar/events/events.py</code> <pre><code>@handle_exception\ndef delete_event(self, calendarId: str, eventId: str, **kwargs) -&gt; dict:\n    '''\n    Delete an event from the specified calendar.\n\n    Args:\n        calendarId (str): The ID of the calendar from which to delete the event.\n        eventId (str): The ID of the event to delete.\n\n    Returns:\n        dict: A status message indicating the deletion was successful.\n\n    ## example\n\n        event = GoogleCredentialService().delete_event(calendarId,eventId)\n\n        ### Example with Optional query parameters\n        ```\n        optional_parameter = {\n            'sendUpdates' : 'all'\n        }\n        calendarId = 'primary'\n        eventId = 'eventId'\n\n        event = CalendarEvent(key)\n        data = event.delete_event(calendarId,eventId,optional_parameter)\n        ```\n\n\n    '''\n    event = self.service.events().delete(calendarId=calendarId,\n                                         eventId=eventId, **kwargs).execute()\n    logger.warning(f'Event with ID {eventId} deleted Successfully.')\n\n    return {'status': 'Deleted', 'event_id': eventId}\n</code></pre>"},{"location":"calendar-events/#red_office_google_integration.calendar.events.events.CalendarEvent.get_event","title":"<code>get_event(calendarId, eventId, **kwargs)</code>","text":"<p>Get details of a specific event from the specified calendar.</p> <p>Parameters:</p> Name Type Description Default <code>calendarId</code> <code>str</code> <p>The ID of the calendar containing the event.</p> required <code>eventId</code> <code>str</code> <p>The ID of the event to retrieve.</p> required <code>**kwargs</code> <code>**kwarg</code> <p>Optional keyword arguments for additional parameters. Refer to the Events: get documentation for details on available parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>The event details.</p> Example <pre><code>event = CalendarEvent(key)\ndata = event.get_event(calendarId, eventId)\n</code></pre> Source code in <code>red_office_google_integration/calendar/events/events.py</code> <pre><code>@handle_exception\ndef get_event(self, calendarId: str, eventId: str, **kwargs) -&gt; dict:\n    '''\n    Get details of a specific event from the specified calendar.\n\n    Args:\n        calendarId (str): The ID of the calendar containing the event.\n        eventId (str): The ID of the event to retrieve.\n        **kwargs (**kwarg): Optional keyword arguments for additional parameters. Refer to the\n            [Events: get documentation](https://developers.google.com/calendar/api/v3/reference/events/get)\n            for details on available parameters.\n\n    Returns:\n        (dict): The event details.\n\n    Example:\n        ```\n        event = CalendarEvent(key)\n        data = event.get_event(calendarId, eventId)\n        ```\n    '''\n    event = self.service.events().get(calendarId=calendarId,\n                                      eventId=eventId, **kwargs).execute()\n    return event\n</code></pre>"},{"location":"calendar-events/#red_office_google_integration.calendar.events.events.CalendarEvent.list_event","title":"<code>list_event(calendarId, optional_parameter)</code>","text":"<p>List events from the specified calendar.</p> <p>Parameters:</p> Name Type Description Default <code>calendarId</code> <code>str</code> <p>The ID of the calendar from which to list events.</p> required <code>optional_parameter</code> <code>dict</code> <p>Optional parameters for listing events. Refer to the Events: list documentation for details on available parameters.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The list of events.</p> Example <pre><code># Example without optional parameters\nevent = GoogleCredentialService(key).list_event(calendarId, {})\n\n# Example with optional query parameters\noptional_parameter = {\n    'maxResults': 2,\n    # Add more optional parameters as needed\n}\nevent = CalendarEvent(key)\ndata = event.list_event(calendarId, optional_parameter)\n</code></pre> Source code in <code>red_office_google_integration/calendar/events/events.py</code> <pre><code>@handle_exception\ndef list_event(self, calendarId: str, optional_parameter: dict) -&gt; dict:\n    '''\n    List events from the specified calendar.\n\n    Args:\n        calendarId (str): The ID of the calendar from which to list events.\n        optional_parameter (dict): Optional parameters for listing events. Refer to the\n            [Events: list documentation](https://developers.google.com/calendar/api/v3/reference/events/list)\n            for details on available parameters.\n\n    Returns:\n        dict: The list of events.\n\n    Example:\n        ```\n        # Example without optional parameters\n        event = GoogleCredentialService(key).list_event(calendarId, {})\n\n        # Example with optional query parameters\n        optional_parameter = {\n            'maxResults': 2,\n            # Add more optional parameters as needed\n        }\n        event = CalendarEvent(key)\n        data = event.list_event(calendarId, optional_parameter)\n        ```\n    '''\n    events = self.service.events().list(\n        calendarId=calendarId, **optional_parameter).execute()\n    return events\n</code></pre>"},{"location":"gmail/","title":"Gmail","text":""},{"location":"gmail/#red_office_google_integration.gmail.mail.Gmail","title":"<code>Gmail</code>","text":"<p>Class for interacting with Gmail API.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The key used for authentication.</p> required <p>Attributes:</p> Name Type Description <code>__key</code> <code>bytes</code> <p>The key used for authentication.</p> <code>__service</code> <p>The Google service.</p> Source code in <code>red_office_google_integration/gmail/mail.py</code> <pre><code>class Gmail:\n    '''\n        Class for interacting with Gmail API.\n\n        Args:\n            key (bytes): The key used for authentication.\n\n        Attributes:\n            __key (bytes): The key used for authentication.\n            __service: The Google service.\n    '''\n\n    def __init__(self, key: bytes) -&gt; None:\n        '''\n        Initialize the Gmail class.\n\n        Args:\n            key (bytes): The key used for authentication.\n        '''\n        self.__key = key\n        self.__service = self.__build_service()\n\n    @handle_exception\n    def __build_service(self):\n        '''\n        Build and return the Google service.\n\n        Returns:\n            (cred): The Google service.\n        '''\n        cred = GoogleCredentialService(self.__key, setting.SCOPE_GMAIL,\n                                       setting.FILE_NAME_GMAIL_TOKEN, setting.FILE_NAME_GMAIL_CREDENTIAL).get_service()\n        return build(\"gmail\", \"v1\", credentials=cred)\n\n    @handle_exception\n    def create_draft(self, email: EmailCreation, userId: str = 'me'):\n        '''\n        Create a draft email in Gmail.\n\n        Args:\n            email (EmailCreation): The email to be created.\n            userId (str, optional): The user ID. Defaults to 'me'.\n\n        Returns:\n            dict: The created draft email.\n        '''\n\n        create_message = {\n            'message': {\"raw\": email.get_mime_message_encoded()}\n        }\n\n        draft = (self.__service.users()\n                 .drafts()\n                 .create(userId=userId, body=create_message)\n                 .execute()\n                 )\n        return draft\n\n    @handle_exception\n    def get_email_list(self, query: str, userId: str = 'me', **kwargs):\n        '''\n            Get a list of emails based on a query.\n\n            Args:\n                query (str): The query to filter emails.\n                userId (str, optional): The user ID. Defaults to 'me'.\n                **kwargs: Additional query parameters.\n\n            Returns:\n                dict: The list of emails matching the query.\n        '''\n        results = self.__service.users().messages().list(\n            userId=userId, q=query, **kwargs).execute()\n        return results\n        # print(json.dumps(results, indent=2))\n\n    @handle_exception\n    def get_email(self, id: str, userId: str = 'me', **kwargs):\n        '''\n            Get an email by ID.\n\n            Args:\n                id (str): The ID of the email.\n                userId (str, optional): The user ID. Defaults to 'me'.\n                **kwargs: Additional query parameters.\n\n            Returns:\n                dict: The email matching the ID.\n        '''\n        result = self.__service.users().messages().get(\n            userId=userId, id=id, **kwargs).execute()\n        return result\n        # print(json.dumps(result, indent=2))\n\n    @handle_exception\n    def get_attachment_encoded(self, messageId: str, attachmentId: str, userId: str = 'me'):\n        '''\n            Get an attachment by its ID.\n\n            Args:\n                messageId (str): The ID of the message containing the attachment.\n                attachmentId (str): The ID of the attachment.\n                userId (str, optional): The user ID. Defaults to 'me'.\n\n            Returns:\n                bytes: The base64-encoded attachment data.\n        '''\n        attachment = self.__service.users().messages().attachments().get(\n            userId=userId, messageId=messageId, id=attachmentId).execute()\n        file_data = attachment['data']\n        return file_data\n</code></pre>"},{"location":"gmail/#red_office_google_integration.gmail.mail.Gmail.__build_service","title":"<code>__build_service()</code>","text":"<p>Build and return the Google service.</p> <p>Returns:</p> Type Description <code>cred</code> <p>The Google service.</p> Source code in <code>red_office_google_integration/gmail/mail.py</code> <pre><code>@handle_exception\ndef __build_service(self):\n    '''\n    Build and return the Google service.\n\n    Returns:\n        (cred): The Google service.\n    '''\n    cred = GoogleCredentialService(self.__key, setting.SCOPE_GMAIL,\n                                   setting.FILE_NAME_GMAIL_TOKEN, setting.FILE_NAME_GMAIL_CREDENTIAL).get_service()\n    return build(\"gmail\", \"v1\", credentials=cred)\n</code></pre>"},{"location":"gmail/#red_office_google_integration.gmail.mail.Gmail.__init__","title":"<code>__init__(key)</code>","text":"<p>Initialize the Gmail class.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The key used for authentication.</p> required Source code in <code>red_office_google_integration/gmail/mail.py</code> <pre><code>def __init__(self, key: bytes) -&gt; None:\n    '''\n    Initialize the Gmail class.\n\n    Args:\n        key (bytes): The key used for authentication.\n    '''\n    self.__key = key\n    self.__service = self.__build_service()\n</code></pre>"},{"location":"gmail/#red_office_google_integration.gmail.mail.Gmail.create_draft","title":"<code>create_draft(email, userId='me')</code>","text":"<p>Create a draft email in Gmail.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>EmailCreation</code> <p>The email to be created.</p> required <code>userId</code> <code>str</code> <p>The user ID. Defaults to 'me'.</p> <code>'me'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The created draft email.</p> Source code in <code>red_office_google_integration/gmail/mail.py</code> <pre><code>@handle_exception\ndef create_draft(self, email: EmailCreation, userId: str = 'me'):\n    '''\n    Create a draft email in Gmail.\n\n    Args:\n        email (EmailCreation): The email to be created.\n        userId (str, optional): The user ID. Defaults to 'me'.\n\n    Returns:\n        dict: The created draft email.\n    '''\n\n    create_message = {\n        'message': {\"raw\": email.get_mime_message_encoded()}\n    }\n\n    draft = (self.__service.users()\n             .drafts()\n             .create(userId=userId, body=create_message)\n             .execute()\n             )\n    return draft\n</code></pre>"},{"location":"gmail/#red_office_google_integration.gmail.mail.Gmail.get_attachment_encoded","title":"<code>get_attachment_encoded(messageId, attachmentId, userId='me')</code>","text":"<p>Get an attachment by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>messageId</code> <code>str</code> <p>The ID of the message containing the attachment.</p> required <code>attachmentId</code> <code>str</code> <p>The ID of the attachment.</p> required <code>userId</code> <code>str</code> <p>The user ID. Defaults to 'me'.</p> <code>'me'</code> <p>Returns:</p> Name Type Description <code>bytes</code> <p>The base64-encoded attachment data.</p> Source code in <code>red_office_google_integration/gmail/mail.py</code> <pre><code>@handle_exception\ndef get_attachment_encoded(self, messageId: str, attachmentId: str, userId: str = 'me'):\n    '''\n        Get an attachment by its ID.\n\n        Args:\n            messageId (str): The ID of the message containing the attachment.\n            attachmentId (str): The ID of the attachment.\n            userId (str, optional): The user ID. Defaults to 'me'.\n\n        Returns:\n            bytes: The base64-encoded attachment data.\n    '''\n    attachment = self.__service.users().messages().attachments().get(\n        userId=userId, messageId=messageId, id=attachmentId).execute()\n    file_data = attachment['data']\n    return file_data\n</code></pre>"},{"location":"gmail/#red_office_google_integration.gmail.mail.Gmail.get_email","title":"<code>get_email(id, userId='me', **kwargs)</code>","text":"<p>Get an email by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the email.</p> required <code>userId</code> <code>str</code> <p>The user ID. Defaults to 'me'.</p> <code>'me'</code> <code>**kwargs</code> <p>Additional query parameters.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The email matching the ID.</p> Source code in <code>red_office_google_integration/gmail/mail.py</code> <pre><code>@handle_exception\ndef get_email(self, id: str, userId: str = 'me', **kwargs):\n    '''\n        Get an email by ID.\n\n        Args:\n            id (str): The ID of the email.\n            userId (str, optional): The user ID. Defaults to 'me'.\n            **kwargs: Additional query parameters.\n\n        Returns:\n            dict: The email matching the ID.\n    '''\n    result = self.__service.users().messages().get(\n        userId=userId, id=id, **kwargs).execute()\n    return result\n</code></pre>"},{"location":"gmail/#red_office_google_integration.gmail.mail.Gmail.get_email_list","title":"<code>get_email_list(query, userId='me', **kwargs)</code>","text":"<p>Get a list of emails based on a query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to filter emails.</p> required <code>userId</code> <code>str</code> <p>The user ID. Defaults to 'me'.</p> <code>'me'</code> <code>**kwargs</code> <p>Additional query parameters.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The list of emails matching the query.</p> Source code in <code>red_office_google_integration/gmail/mail.py</code> <pre><code>@handle_exception\ndef get_email_list(self, query: str, userId: str = 'me', **kwargs):\n    '''\n        Get a list of emails based on a query.\n\n        Args:\n            query (str): The query to filter emails.\n            userId (str, optional): The user ID. Defaults to 'me'.\n            **kwargs: Additional query parameters.\n\n        Returns:\n            dict: The list of emails matching the query.\n    '''\n    results = self.__service.users().messages().list(\n        userId=userId, q=query, **kwargs).execute()\n    return results\n</code></pre>"},{"location":"google_service_credential_service/","title":"Google Credentials Service","text":""},{"location":"google_service_credential_service/#red_office_google_integration.google_service.google_credentials_service.GoogleCredentialService","title":"<code>GoogleCredentialService</code>","text":"<p>A class for managing Google Calendar API credentials and interacting with the service.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The encryption key.</p> required <code>scope</code> <code>list[str]</code> <p>The Google API scope.</p> required <code>token_file_name</code> <code>str</code> <p>The name of the file containing the token.</p> required <code>credential_file_name</code> <code>str</code> <p>The name of the file containing the credentials.</p> required <p>Methods:</p> Name Description <code>get_service</code> <p>Retrieves the Google Calendar service.</p> <code>load_credentials</code> <p>Loads the Google Calendar API credentials.</p> <code>refresh_or_acquire_new_token</code> <p>Refreshes or acquires a new Google Calendar API token.</p> <code>save_token</code> <p>Saves the Google Calendar API token.</p> <p>Example: <pre><code>google_cal_service = GoogleCalendarService(key, scope, 'token.json', 'credentials.json')\nservice = google_cal_service.get_service()\nservice.events().insert(calendarId=calendarId, body=event_data).execute()\n</code></pre></p> TODO <ul> <li>Write unit tests.</li> <li>Add more documentation.</li> <li>Optimize the code.</li> </ul> Source code in <code>red_office_google_integration/google_service/google_credentials_service.py</code> <pre><code>class GoogleCredentialService:\n    '''\n        A class for managing Google Calendar API credentials and interacting with the service.\n\n        Args:\n            key (bytes): The encryption key.\n            scope (list[str]): The Google API scope.\n            token_file_name (str): The name of the file containing the token.\n            credential_file_name (str): The name of the file containing the credentials.\n\n        Methods:\n            get_service(): Retrieves the Google Calendar service.\n            load_credentials(): Loads the Google Calendar API credentials.\n            refresh_or_acquire_new_token(): Refreshes or acquires a new Google Calendar API token.\n            save_token(): Saves the Google Calendar API token.\n\n        Example:\n        ```\n        google_cal_service = GoogleCalendarService(key, scope, 'token.json', 'credentials.json')\n        service = google_cal_service.get_service()\n        service.events().insert(calendarId=calendarId, body=event_data).execute()\n        ```\n\n        TODO:\n            - Write unit tests.\n            - Add more documentation.\n            - Optimize the code.\n    '''\n\n    def __init__(self, key: bytes, scope: list[str], token_file_name: str, credential_file_name: str) -&gt; None:\n        \"\"\"\n            Initializes a new instance of the GoogleCalendarService class.\n\n            Args:\n                key (bytes): The encryption key.\n                scope (list[str]): The Google API scope.\n                token_file_name (str): The name of the file containing the token.\n                credential_file_name (str): The name of the file containing the credentials.\n\n            Returns:\n                None\n        \"\"\"\n        self.key = key\n        self.scope = scope\n        self.token_file_path = setting.SECRET_DIRECTORY_PATH / token_file_name\n        self.credential_file_path = setting.SECRET_DIRECTORY_PATH / credential_file_name\n\n    @utils.handle_exception\n    def get_service(self) -&gt; Credentials:\n        '''\n\n        Returns:\n            Any: The Google Calendar service credentials. \n\n        '''\n        creds = self.load_credentials()\n        return creds\n\n    @utils.handle_exception\n    def load_credentials(self):\n        '''\n            Loads the credentials from the specified token file, decrypting it if necessary, and handles token expiration.\n\n            Returns:\n                Credentials: The loaded and decrypted Google OAuth2 credentials.\n        NOTE: to pass provide_temp_decrypted_file_path used inner function so we can pass selfs\n        '''\n        @provide_temp_decrypted_file_path(self.token_file_path, self.key)\n        def inner_func(token_path: pathlib.Path | FileError):\n            creds = None\n            if type(token_path) != FileError:\n                creds = Credentials.from_authorized_user_file(\n                    token_path, self.scope)\n            if not creds or not creds.valid:\n                creds = self.refresh_or_acquire_new_token(creds)\n            return creds\n        return inner_func()\n\n    @utils.handle_exception\n    def refresh_or_acquire_new_token(self, creds):\n        @provide_temp_decrypted_file_path(self.credential_file_path, self.key)\n        def inner_func(file_path, inner_creds):\n            if type(file_path) == FileError:\n                raise FileError(f\"{file_path}\")\n            if inner_creds and inner_creds.expired and inner_creds.refresh_token:\n                inner_creds.refresh(Request())\n\n            else:\n                flow = InstalledAppFlow.from_client_secrets_file(\n                    file_path, self.scope)\n                inner_creds = flow.run_local_server(port=0)\n                self.save_token(inner_creds.to_json())\n            return inner_creds\n\n        return inner_func(creds)\n\n    @utils.handle_exception\n    def save_token(self, creds):\n        encrypt_and_save_file(self.token_file_path, creds, self.key)\n</code></pre>"},{"location":"google_service_credential_service/#red_office_google_integration.google_service.google_credentials_service.GoogleCredentialService.__init__","title":"<code>__init__(key, scope, token_file_name, credential_file_name)</code>","text":"<p>Initializes a new instance of the GoogleCalendarService class.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The encryption key.</p> required <code>scope</code> <code>list[str]</code> <p>The Google API scope.</p> required <code>token_file_name</code> <code>str</code> <p>The name of the file containing the token.</p> required <code>credential_file_name</code> <code>str</code> <p>The name of the file containing the credentials.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>red_office_google_integration/google_service/google_credentials_service.py</code> <pre><code>def __init__(self, key: bytes, scope: list[str], token_file_name: str, credential_file_name: str) -&gt; None:\n    \"\"\"\n        Initializes a new instance of the GoogleCalendarService class.\n\n        Args:\n            key (bytes): The encryption key.\n            scope (list[str]): The Google API scope.\n            token_file_name (str): The name of the file containing the token.\n            credential_file_name (str): The name of the file containing the credentials.\n\n        Returns:\n            None\n    \"\"\"\n    self.key = key\n    self.scope = scope\n    self.token_file_path = setting.SECRET_DIRECTORY_PATH / token_file_name\n    self.credential_file_path = setting.SECRET_DIRECTORY_PATH / credential_file_name\n</code></pre>"},{"location":"google_service_credential_service/#red_office_google_integration.google_service.google_credentials_service.GoogleCredentialService.get_service","title":"<code>get_service()</code>","text":"<p>Returns:</p> Name Type Description <code>Any</code> <code>Credentials</code> <p>The Google Calendar service credentials.</p> Source code in <code>red_office_google_integration/google_service/google_credentials_service.py</code> <pre><code>@utils.handle_exception\ndef get_service(self) -&gt; Credentials:\n    '''\n\n    Returns:\n        Any: The Google Calendar service credentials. \n\n    '''\n    creds = self.load_credentials()\n    return creds\n</code></pre>"},{"location":"google_service_credential_service/#red_office_google_integration.google_service.google_credentials_service.GoogleCredentialService.load_credentials","title":"<code>load_credentials()</code>","text":"<pre><code>Loads the credentials from the specified token file, decrypting it if necessary, and handles token expiration.\n\nReturns:\n    Credentials: The loaded and decrypted Google OAuth2 credentials.\n</code></pre> <p>NOTE: to pass provide_temp_decrypted_file_path used inner function so we can pass selfs</p> Source code in <code>red_office_google_integration/google_service/google_credentials_service.py</code> <pre><code>@utils.handle_exception\ndef load_credentials(self):\n    '''\n        Loads the credentials from the specified token file, decrypting it if necessary, and handles token expiration.\n\n        Returns:\n            Credentials: The loaded and decrypted Google OAuth2 credentials.\n    NOTE: to pass provide_temp_decrypted_file_path used inner function so we can pass selfs\n    '''\n    @provide_temp_decrypted_file_path(self.token_file_path, self.key)\n    def inner_func(token_path: pathlib.Path | FileError):\n        creds = None\n        if type(token_path) != FileError:\n            creds = Credentials.from_authorized_user_file(\n                token_path, self.scope)\n        if not creds or not creds.valid:\n            creds = self.refresh_or_acquire_new_token(creds)\n        return creds\n    return inner_func()\n</code></pre>"},{"location":"google_service_file_handler/","title":"File Handler","text":"<p>This module contains functions for encrypting and decrypting files, as well as a decorator function to create a temporary file that holds decrypted data and injects it into a function. This is especially useful for Google credentials, which require a file path and cannot use an encrypted file path.</p> <p>Functions:</p> Name Description <code>- decrypt_file</code> <p>Decrypts a file using a generated key.</p> <code>- provide_temp_decrypted_file_path</code> <p>Provides the temporary path for the decrypted file.</p> <code>- generate_key</code> <p>Generates a key for encryption and decryption.</p> <code>- encrypt_and_save_file</code> <p>Encrypts and saves a file.</p> <p>NOTE:     when token is invalid or filenot exist we have to generate new one but when credentials dosen't exit or     invalid throw error. so my function right now is not well structured TODO:     Write unit tests</p> <pre><code>OPTIONAL\n    - encrypt_data\n</code></pre>"},{"location":"google_service_file_handler/#red_office_google_integration.google_service.file_handler.FileError","title":"<code>FileError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>This exception is specifically designed for use with the <code>provide_temp_decrypted_file_path</code> decorator function.  The decorator function decrypts a token or credentials file, creates a temporary path, and passes it to the decorated function.  After the decorated function is executed, it destroys the decrypted file.</p> <p>In the case of a token, if there is a problem with the file, it raises a FileNotFoundError so that the GoogleCredential  can generate a new token. However, in the case of credentials, it must throw an error. </p> <p>Usage in token:</p> <p>if type(path) == FileNotFoundError:     get_new_token()</p> <p>Usage in credentials:</p> <p>if type(path) == FileNotFoundError:     raise FileError(\"Credentials file not found\")</p> Source code in <code>red_office_google_integration/google_service/file_handler.py</code> <pre><code>class FileError(Exception):\n    \"\"\"\n        This exception is specifically designed for use with the `provide_temp_decrypted_file_path` decorator function. \n        The decorator function decrypts a token or credentials file, creates a temporary path, and passes it to the decorated function. \n        After the decorated function is executed, it destroys the decrypted file.\n\n        In the case of a token, if there is a problem with the file, it raises a FileNotFoundError so that the GoogleCredential \n        can generate a new token. However, in the case of credentials, it must throw an error. \n\n        Usage in token:\n\n        if type(path) == FileNotFoundError:\n            get_new_token()\n\n        Usage in credentials:\n\n        if type(path) == FileNotFoundError:\n            raise FileError(\"Credentials file not found\")\n    \"\"\"\n\n    def __init__(self, message=\"File error occured\", *args: object) -&gt; None:\n        super().__init__(message, *args)\n        self.message = message\n</code></pre>"},{"location":"google_service_file_handler/#red_office_google_integration.google_service.file_handler.InitializeCredential","title":"<code>InitializeCredential</code>","text":"<p>A class for initializing and encrypting credential data and saving it to a file.</p> <p>Args: - cred_data (str): The credential data to be encrypted. - file_name (str): The name of the file to save the encrypted data. - key (bytes, optional): The encryption key. Defaults to a randomly generated key.</p> <p>Attributes: - encrypted_data (bytes): The encrypted credential data. - status (str): The status of the initialization process. Default is 'pending'.</p> <p>Methods: - initialize(): Encrypts the credential data and saves it to the specified file. - get_key(): Returns the encryption key.</p> <p>Example: <pre><code>credential = InitializeCredential(cred_data, file_name)\ncredential.initialize()\nkey = credential.get_key()\n</code></pre></p> Source code in <code>red_office_google_integration/google_service/file_handler.py</code> <pre><code>class InitializeCredential:\n    \"\"\"\n    A class for initializing and encrypting credential data and saving it to a file.\n\n    Args:\n    - cred_data (str): The credential data to be encrypted.\n    - file_name (str): The name of the file to save the encrypted data.\n    - key (bytes, optional): The encryption key. Defaults to a randomly generated key.\n\n    Attributes:\n    - encrypted_data (bytes): The encrypted credential data.\n    - status (str): The status of the initialization process. Default is 'pending'.\n\n    Methods:\n    - initialize(): Encrypts the credential data and saves it to the specified file.\n    - get_key(): Returns the encryption key.\n\n    Example:\n    ```\n    credential = InitializeCredential(cred_data, file_name)\n    credential.initialize()\n    key = credential.get_key()\n    ```\n    \"\"\"\n\n    def __init__(self, cred_data: str, file_name: str, key: bytes = generate_key()) -&gt; None:\n        \"\"\"\n        Initialize the InitializeCredential class.\n\n        Args:\n            cred_data (str): The credential data to be encrypted.\n            file_name (str): The name of the file to save the encrypted data.\n            key (bytes, optional): The encryption key. Defaults to a randomly generated key.\n\n        Attributes:\n            encrypted_data (bytes): The encrypted credential data.\n            status (str): The status of the initialization process. Default is 'pending'.\n        \"\"\"\n        self.__key = key\n        self.__cred_data = cred_data\n        self.encrypted_data: bytes\n        self.__file_path = setting.SECRET_DIRECTORY_PATH / file_name\n        self.status = 'pending'\n\n    def initialize(self):\n        \"\"\"\n        Encrypts the credential data, saves it to the specified file, and updates the `encrypted_data`\n        attribute with the encrypted data. It also sets the `status` attribute to 'success'.\n        \"\"\"\n        encrypt_and_save_file(self.__file_path, self.__cred_data, self.__key)\n\n        def get_raw_data(file_path: pathlib.Path) -&gt; bytes:\n            with open(file_path, 'rb') as f:\n                return f.read()\n\n        self.encrypted_data = get_raw_data(self.__file_path)\n        self.status = 'success'\n\n    def get_key(self):\n        \"\"\"\n        Returns the encryption key.\n\n        Returns: bytes: The encryption key.\n        \"\"\"\n        return self.__key\n</code></pre>"},{"location":"google_service_file_handler/#red_office_google_integration.google_service.file_handler.InitializeCredential.__init__","title":"<code>__init__(cred_data, file_name, key=generate_key())</code>","text":"<p>Initialize the InitializeCredential class.</p> <p>Parameters:</p> Name Type Description Default <code>cred_data</code> <code>str</code> <p>The credential data to be encrypted.</p> required <code>file_name</code> <code>str</code> <p>The name of the file to save the encrypted data.</p> required <code>key</code> <code>bytes</code> <p>The encryption key. Defaults to a randomly generated key.</p> <code>generate_key()</code> <p>Attributes:</p> Name Type Description <code>encrypted_data</code> <code>bytes</code> <p>The encrypted credential data.</p> <code>status</code> <code>str</code> <p>The status of the initialization process. Default is 'pending'.</p> Source code in <code>red_office_google_integration/google_service/file_handler.py</code> <pre><code>def __init__(self, cred_data: str, file_name: str, key: bytes = generate_key()) -&gt; None:\n    \"\"\"\n    Initialize the InitializeCredential class.\n\n    Args:\n        cred_data (str): The credential data to be encrypted.\n        file_name (str): The name of the file to save the encrypted data.\n        key (bytes, optional): The encryption key. Defaults to a randomly generated key.\n\n    Attributes:\n        encrypted_data (bytes): The encrypted credential data.\n        status (str): The status of the initialization process. Default is 'pending'.\n    \"\"\"\n    self.__key = key\n    self.__cred_data = cred_data\n    self.encrypted_data: bytes\n    self.__file_path = setting.SECRET_DIRECTORY_PATH / file_name\n    self.status = 'pending'\n</code></pre>"},{"location":"google_service_file_handler/#red_office_google_integration.google_service.file_handler.InitializeCredential.get_key","title":"<code>get_key()</code>","text":"<p>Returns the encryption key.</p> <p>Returns: bytes: The encryption key.</p> Source code in <code>red_office_google_integration/google_service/file_handler.py</code> <pre><code>def get_key(self):\n    \"\"\"\n    Returns the encryption key.\n\n    Returns: bytes: The encryption key.\n    \"\"\"\n    return self.__key\n</code></pre>"},{"location":"google_service_file_handler/#red_office_google_integration.google_service.file_handler.InitializeCredential.initialize","title":"<code>initialize()</code>","text":"<p>Encrypts the credential data, saves it to the specified file, and updates the <code>encrypted_data</code> attribute with the encrypted data. It also sets the <code>status</code> attribute to 'success'.</p> Source code in <code>red_office_google_integration/google_service/file_handler.py</code> <pre><code>def initialize(self):\n    \"\"\"\n    Encrypts the credential data, saves it to the specified file, and updates the `encrypted_data`\n    attribute with the encrypted data. It also sets the `status` attribute to 'success'.\n    \"\"\"\n    encrypt_and_save_file(self.__file_path, self.__cred_data, self.__key)\n\n    def get_raw_data(file_path: pathlib.Path) -&gt; bytes:\n        with open(file_path, 'rb') as f:\n            return f.read()\n\n    self.encrypted_data = get_raw_data(self.__file_path)\n    self.status = 'success'\n</code></pre>"},{"location":"google_service_file_handler/#red_office_google_integration.google_service.file_handler.decrypt_file","title":"<code>decrypt_file(path, key)</code>","text":"<p>Decrypts the data from the specified file path using the provided key.</p> <p>:param path: The path to the encrypted file.     - param key: The encryption/decryption key.     - return: The decrypted data.</p> Source code in <code>red_office_google_integration/google_service/file_handler.py</code> <pre><code>def decrypt_file(path: pathlib.Path, key: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypts the data from the specified file path using the provided key.\n\n    :param path: The path to the encrypted file.\n        - param key: The encryption/decryption key.\n        - return: The decrypted data.\n    \"\"\"\n    try:\n        cipher = Fernet(key)\n        with open(path, 'rb') as f:\n            data = f.read()\n        decrypted_data = cipher.decrypt(data)\n        return decrypted_data\n\n    except InvalidToken:\n        raise InvalidToken(\"Invalid key or corrupted file\")\n    except Exception as e:\n        raise Exception(f\"Something went wrong while decryption: {e}\")\n</code></pre>"},{"location":"google_service_file_handler/#red_office_google_integration.google_service.file_handler.encrypt_and_save_file","title":"<code>encrypt_and_save_file(file_path, data, key)</code>","text":"<p>Encrypts the provided data and saves it to the specified file path.</p> <p>:param file_path: The path to save the encrypted data. :param data: The data to encrypt and save. :param key: The encryption/decryption key.</p> Source code in <code>red_office_google_integration/google_service/file_handler.py</code> <pre><code>def encrypt_and_save_file(file_path: pathlib.Path, data: str, key: bytes) -&gt; None:\n    \"\"\"\n    Encrypts the provided data and saves it to the specified file path.\n\n    :param file_path: The path to save the encrypted data.\n    :param data: The data to encrypt and save.\n    :param key: The encryption/decryption key.\n    \"\"\"\n    cipher = Fernet(key)\n    with open(file_path, 'wb') as f:\n        encrypted_data = cipher.encrypt(data.encode())\n        f.write(encrypted_data)\n</code></pre>"},{"location":"google_service_file_handler/#red_office_google_integration.google_service.file_handler.generate_key","title":"<code>generate_key()</code>","text":"<p>Generates a Fernet key.</p> <p>:return: A Fernet key in bytes format.</p> Source code in <code>red_office_google_integration/google_service/file_handler.py</code> <pre><code>def generate_key() -&gt; bytes:\n    \"\"\"\n    Generates a Fernet key.\n\n    :return: A Fernet key in bytes format.\n    \"\"\"\n    return Fernet.generate_key()\n</code></pre>"},{"location":"google_service_file_handler/#red_office_google_integration.google_service.file_handler.provide_temp_decrypted_file_path","title":"<code>provide_temp_decrypted_file_path(encrypted_file_path, key)</code>","text":"<p>A decorator function that decrypts the data from the specified file path using the provided key, stores the decrypted data in a temporary file, and injects the temporary file path to the decorated function. The temporary file is deleted after the decorated function is executed.</p> <p>:param encrypted_file_path: The path to the encrypted file. :param key: The encryption/decryption key in bytes. :return: The wrapper function.</p> <p>Example:</p> <p>@provide_temp_decrypted_file_path(encrypted_filepath, key) def func(file_path: pathlib.Path):     # your statement here</p> Source code in <code>red_office_google_integration/google_service/file_handler.py</code> <pre><code>def provide_temp_decrypted_file_path(encrypted_file_path: pathlib.Path, key: bytes) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    A decorator function that decrypts the data from the specified file path using the provided key,\n    stores the decrypted data in a temporary file, and injects the temporary file path to the decorated function.\n    The temporary file is deleted after the decorated function is executed.\n\n    :param encrypted_file_path: The path to the encrypted file.\n    :param key: The encryption/decryption key in bytes.\n    :return: The wrapper function.\n\n    Example:\n\n    @provide_temp_decrypted_file_path(encrypted_filepath, key)\n    def func(file_path: pathlib.Path):\n        # your statement here\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        \"\"\"\n            The actual decorator that injects the temporary file path to the decorated function.\n\n            :param func: The function to be decorated.\n            :return: The wrapper function.\n        \"\"\"\n        def wrapper(*args, **kwargs):\n            # Create a temporary file to store the decrypted data\n            temp_decrypted_file = tempfile.NamedTemporaryFile(delete=False)\n            temp_file_path = None\n            cipher = Fernet(key)\n            try:\n                with open(encrypted_file_path, 'rb') as f:\n                    data = f.read()\n                    decrypted_data = cipher.decrypt(data)\n\n                # Write the decrypted data to the temporary file\n                temp_decrypted_file.write(decrypted_data)\n                temp_decrypted_file.flush()\n                temp_file_path = temp_decrypted_file.name\n\n                # Inject the temporary file path to the decorated function\n                return func(pathlib.Path(temp_file_path), *args, **kwargs)\n            except (FileNotFoundError, FileExistsError, PermissionError) as e:\n                return func(FileError(f'FileError: {type(e).__name__} -&gt; {os.path.basename(encrypted_file_path)}'), *args, **kwargs)\n            finally:\n                # Close and delete the temporary file\n                if temp_file_path is not None:\n                    temp_decrypted_file.close()\n                    os.remove(temp_file_path)\n\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"log/","title":"Log Handler","text":"<p>Module for handling logging functionality.</p> <p>This module sets up logging configuration using a custom JSONLinesFormatter and a RotatingFileHandler. It provides a structured way to log messages with timestamps, log levels, messages, module names, and line numbers.</p> <p>Example Usage: <pre><code>    logger.critical(\"Critical message\")\n    logger.error(\"Error message\")\n    logger.debug(\"Debug message\")\n    logger.warning(\"Warning message\")\n    logger.info(\"Info message\")\n</code></pre></p>"},{"location":"log/#red_office_google_integration.log.log_handler.JSONLinesFormatter","title":"<code>JSONLinesFormatter</code>","text":"<p>             Bases: <code>Formatter</code></p> <p>A custom formatter for logging that formats records as JSON lines.</p> <p>Usage: formatter = JSONLinesFormatter() file_handler.setFormatter(formatter)</p> Source code in <code>red_office_google_integration/log/log_handler.py</code> <pre><code>class JSONLinesFormatter(logging.Formatter):\n    \"\"\"\n    A custom formatter for logging that formats records as JSON lines.\n\n    Usage:\n    formatter = JSONLinesFormatter()\n    file_handler.setFormatter(formatter)\n    \"\"\"\n\n    def format(self, record):\n        \"\"\"\n        Format the log record as a JSON object.\n\n        Args:\n            record (LogRecord): The log record to be formatted.\n\n        Returns:\n            (str): JSON representation of the log record.\n        \"\"\"\n        message = {\n            'timestamp': self.formatTime(record),\n            'level': record.levelname,\n            'message': record.getMessage(),\n            'module': record.module,\n            'line': record.lineno\n        }\n        return json.dumps(message)\n</code></pre>"},{"location":"log/#red_office_google_integration.log.log_handler.JSONLinesFormatter.format","title":"<code>format(record)</code>","text":"<p>Format the log record as a JSON object.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to be formatted.</p> required <p>Returns:</p> Type Description <code>str</code> <p>JSON representation of the log record.</p> Source code in <code>red_office_google_integration/log/log_handler.py</code> <pre><code>def format(self, record):\n    \"\"\"\n    Format the log record as a JSON object.\n\n    Args:\n        record (LogRecord): The log record to be formatted.\n\n    Returns:\n        (str): JSON representation of the log record.\n    \"\"\"\n    message = {\n        'timestamp': self.formatTime(record),\n        'level': record.levelname,\n        'message': record.getMessage(),\n        'module': record.module,\n        'line': record.lineno\n    }\n    return json.dumps(message)\n</code></pre>"},{"location":"project_structure/","title":"Project Structure","text":""},{"location":"project_structure/#project-structure","title":"Project Structure","text":"<p>The project is structured as follows:</p> <ul> <li> <p>red_office_google_integration: All components are contained within this package.</p> </li> <li> <p>google-service: This package manages credentials, generates tokens, and securely stores credentials in an encrypted file using a Fernet key. The package provides a <code>Cred</code> object when requested, allowing actions to be performed on it.</p> </li> <li> <p>calendar: Contains methods for managing calendar events, such as creating, listing, deleting, and getting events.</p> </li> <li> <p>spreadsheet: Contains methods for managing spreadsheet events, such as get-data, get-batch-data,update-values, updata-batch-values, append-data.</p> </li> <li> <p>mail: Contains methods for maniging emails , such as create-draft, delete-email, get-email, download-attachment, get list of mail using query.</p> </li> <li> <p>log: Configuration file for logging settings.</p> </li> <li> <p>src: Contains utility functions and project settings.</p> </li> <li> <p>tests: Contains test cases.</p> </li> <li> <p>CLI_handler: Directory containing CLI modules for calendar, sheet, and Gmail. These modules are imported into <code>main.py</code>, which handles arguments and performs operations based on the command type. For example, <code>py main.py calendar ...</code> is used to interact with the calendar module.</p> </li> <li> <p>main.py: The main entry point for the project. It interacts with the project through the CLI. <code>main.py</code> takes arguments via the CLI and calls the corresponding CLI packages based on the command type. It does not contain all commands but rather delegates them to the relevant modules, such as calendar. For example, <code>py main.py calendar ...</code> would be used to interact with the calendar CLI package.</p> </li> <li> <p>Docs: Contains documentation files. The documentation is built using MkDocs. File references and configurations are specified in <code>mkdocs.yml</code>. Running <code>mkdocs serve</code> in the base directory fetches all mentioned files, extracts docstrings, and presents them beautifully in localhost. HTML documentation files can also be generated if needed.</p> </li> </ul>"},{"location":"setup_guide/","title":"Setup Guide","text":""},{"location":"setup_guide/#setup","title":"SETUP","text":"<ol> <li> <p>Setup Python 3.10:    Ensure you have Python 3.10 installed on your system. You can download it from the official Python website.</p> </li> <li> <p>Clone the Repository:    Use the following command to clone the repository:    <pre><code>git clone https://github.com/TechSage369/RED-OFFICE-GOOGLE-INTEGRATION.git\n</code></pre></p> </li> <li> <p>Install Dependencies: <pre><code>pip install -r requirement.txt\n</code></pre></p> </li> <li>CLI Commands: Here's the corrected version of the CLI commands section in Markdown format:</li> </ol>"},{"location":"setup_guide/#initialize-credentials","title":"Initialize Credentials","text":"<p>please follow this link till credential creation and save to json file</p> <p>Python quickstart \u00a0|\u00a0 Google Calendar \u00a0|\u00a0 Google for Developers</p> <p><code>After getting credential</code></p>"},{"location":"setup_guide/#setup-credentials","title":"Setup Credentials","text":"<p>To initialize your credentials, provide the credential file name. You will receive the key in the terminal (also can specify output file[optional]), which you should keep safe for later use as API_KEY.</p> <pre><code>py main.py init-cred credential_filename -o outputfilename\n</code></pre> <p>You can also use optional parameters to specify a custom key (e.g., <code>Lb-9cbIFCUCFcKSrWqRyEvEYuHAOB6pfMLpmHbrdnNA=</code>) and mention the output file path to save the key. <code>Fernet key 128-bit base64-encoded</code></p> <pre><code>py main.py init-cred credential_filename -o outputfilename -k YOUR_SECRET_KEY\n</code></pre> <p>Make sure to replace <code>credential_filename</code> with the name of your credential file and <code>outputfilename</code> with the desired output file path.</p>"},{"location":"source/","title":"Source","text":""},{"location":"source/#red_office_google_integration.src.utils.handle_exception","title":"<code>handle_exception(func)</code>","text":"<p>Decorator function for exception handling.</p> <p>This decorator function is used for exception handling in various modules of the project. It catches specific exceptions, logs them using the project's logger, prints the error message (in dict format), and exits the program with a status code of 1.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function</code> <p>The function to be decorated.</p> required <p>Returns:</p> Name Type Description <code>wrapper</code> <code>function</code> <p>The wrapped function with exception handling logic.</p> Exceptions Handled <ul> <li>HttpError: Handles Google API HTTP errors, extracting relevant information such as status code and message.</li> <li>InvalidJsonError, TypeError, FileNotFoundError, FileExistsError, InvalidToken: Handles specific errors with custom error messages.</li> <li>Exception: Handles all other exceptions with a generic error message.</li> </ul> Logging <p>Logs the error message using the project's logger with the following format:     {         'status': ,         'status_code': ,         'message': ,         'function_name':      } <p>Usage: <pre><code>@handle_exception\ndef my_function():\n    # Function code that may raise exceptions\n    pass\n</code></pre></p> Source code in <code>red_office_google_integration/src/utils.py</code> <pre><code>def handle_exception(func: Callable[..., Any]):\n    '''\n    Decorator function for exception handling.\n\n    This decorator function is used for exception handling in various modules of the project.\n    It catches specific exceptions, logs them using the project's logger, prints the error message (in dict format),\n    and exits the program with a status code of 1.\n\n    Parameters:\n        func (function): The function to be decorated.\n\n    Returns:\n        wrapper (function): The wrapped function with exception handling logic.\n\n    Exceptions Handled:\n        - HttpError: Handles Google API HTTP errors, extracting relevant information such as status code and message.\n        - InvalidJsonError, TypeError, FileNotFoundError, FileExistsError, InvalidToken: Handles specific errors with custom error messages.\n        - Exception: Handles all other exceptions with a generic error message.\n\n    Logging:\n        Logs the error message using the project's logger with the following format:\n            {\n                'status': &lt;Exception Type&gt;,\n                'status_code': &lt;HTTP Status Code if applicable&gt;,\n                'message': &lt;Exception Message&gt;,\n                'function_name': &lt;Name of the Function where the Exception Occurred&gt;\n            }\n\n    Usage:\n    ```\n    @handle_exception\n    def my_function():\n        # Function code that may raise exceptions\n        pass\n    ```\n    '''\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except HttpError as e:\n            error_message = {\n                'status': type(e).__name__,\n                'status_code': e.resp.status,\n                'message': e._get_reason(),\n                'function_name': func.__name__\n            }\n        # except (InvalidJsonError, TypeError, FileNotFoundError, FileExistsError, InvalidToken) as e:\n        #     error_message = {\n        #         'status': type(e).__name__,\n        #         'message': str(e),\n        #         'function_name': func.__name__\n        #     }\n        except Exception as e:\n            error_message = {\n                'status': type(e).__name__,\n                'message': str(e),\n                'function_name': func.__name__\n            }\n\n        logger.error(error_message)\n        print(json.dumps(error_message))\n        sys.exit(1)\n\n    return wrapper\n</code></pre>"},{"location":"source/#settings","title":"Settings","text":"<p>Contains Settings for this project</p>"},{"location":"spreadsheet/","title":"Sheet","text":""},{"location":"spreadsheet/#red_office_google_integration.spreadsheets.sheets.SpreadSheet","title":"<code>SpreadSheet</code>","text":"<p>A class for interacting with Google Sheets API to read, update, and append data.</p> <p>Attributes: - __key (bytes): The key used for authentication. - __service: The Google Sheets service instance.</p> <p>Methods: - init(self, key: bytes): Initializes the SpreadSheet class with the given authentication key. - get_data(self, spreadsheetId: str, range: str, kwargs) -&gt; dict: Retrieves data from a specified range in a Google Sheets spreadsheet. - get_batch_data(self, spreadsheetId: str, ranges: list[str], kwargs) -&gt; dict: Retrieves data from multiple specified ranges in a Google Sheets spreadsheet. - update_values(self, spreadsheetId: str, range: str, valueInputOption: str, values: list[list], kwargs) -&gt; dict: Updates values in a Google Sheet within the specified range. - batch_update_values(self, spreadsheet_id: str, valueInputOption, data: list[dict], kwargs) -&gt; dict: Updates multiple cells in a Google Sheet using a single batch update API call. - append_data(self, spreadsheetId: str, range: str, valueInputOption: str, values: list[list], **kwargs) -&gt; dict: Appends values to a Google Sheet starting from the specified range.</p> Source code in <code>red_office_google_integration/spreadsheets/sheets.py</code> <pre><code>class SpreadSheet:\n    \"\"\"\n    A class for interacting with Google Sheets API to read, update, and append data.\n\n    Attributes:\n    - __key (bytes): The key used for authentication.\n    - __service: The Google Sheets service instance.\n\n    Methods:\n    - __init__(self, key: bytes): Initializes the SpreadSheet class with the given authentication key.\n    - get_data(self, spreadsheetId: str, range: str, **kwargs) -&gt; dict: Retrieves data from a specified range in a Google Sheets spreadsheet.\n    - get_batch_data(self, spreadsheetId: str, ranges: list[str], **kwargs) -&gt; dict: Retrieves data from multiple specified ranges in a Google Sheets spreadsheet.\n    - update_values(self, spreadsheetId: str, range: str, valueInputOption: str, values: list[list], **kwargs) -&gt; dict: Updates values in a Google Sheet within the specified range.\n    - batch_update_values(self, spreadsheet_id: str, valueInputOption, data: list[dict], **kwargs) -&gt; dict: Updates multiple cells in a Google Sheet using a single batch update API call.\n    - append_data(self, spreadsheetId: str, range: str, valueInputOption: str, values: list[list], **kwargs) -&gt; dict: Appends values to a Google Sheet starting from the specified range.\n    \"\"\"\n\n    def __init__(self, key: bytes) -&gt; None:\n        '''\n        Initialize the CalendarEvent class.\n\n        Args:\n            key (bytes): The key used for authentication.\n        '''\n        self.__key = key\n        self.__service = self.__build_service()\n\n    @handle_exception\n    def __build_service(self):\n        '''\n        Build and return the Google service.\n\n        Returns:\n            (cred): The Google service.\n        '''\n        cred = GoogleCredentialService(self.__key, setting.SCOPE_SPREADSHEETS,\n                                       setting.FILE_NAME_SPREADSHEETS_TOKEN, setting.FILE_NAME_SPREADSHEETS_CREDENTIAL).get_service()\n        return build(\"sheets\", \"v4\",  credentials=cred)\n\n    @handle_exception\n    def get_data(self, spreadsheetId: str, range: str, **kwargs):\n        \"\"\"\n        Retrieves data from a specified range in a Google Sheets spreadsheet.\n\n        Parameters:\n        - spreadsheetId (str): The ID of the spreadsheet to retrieve data from.\n        - range (str): The A1 notation or R1C1 notation of the range to retrieve values from. just giving sheet name will return all the data from sheet\n        - kwargs: Additional query parameters.\n\n        Query Parameters:\n        - majorDimension (enum): The major dimension that results should use.\n        For example, if the spreadsheet data in Sheet1 is: A1=1,B1=2,A2=3,B2=4,\n        then requesting majorDimension='ROWS' returns [[1,2],[3,4]],\n        whereas requesting majorDimension='COLUMNS' returns [[1,3],[2,4]].\n        `I don't prefer to use this parameter. We'll use ROW majorDimension for our proejct which is default.`\n\n        - valueRenderOption (enum): How values should be represented in the output.\n        The default render option is FORMATTED_VALUE.\n        - dateTimeRenderOption (enum): How dates, times, and durations should be represented in the output.\n        This is ignored if valueRenderOption is FORMATTED_VALUE.\n        The default dateTime render option is SERIAL_NUMBER.\n\n        Returns:\n        - dict: A dictionary containing the retrieved values.\n\n        Raises:\n        - Exception: If there is an error while retrieving the data.\n    \"\"\"\n        return self.__service.spreadsheets().values().get(spreadsheetId=spreadsheetId,\n                                                          range=range, **kwargs).execute()\n\n    @handle_exception\n    def get_batch_data(self, spreadsheetId: str, ranges: list[str], **kwargs) -&gt; dict:\n        \"\"\"\n        Retrieves data from multiple specified ranges in a Google Sheets spreadsheet.\n\n        Parameters:\n        - spreadsheetId (str): The ID of the spreadsheet to retrieve data from.\n        - ranges (list[str]): A list of A1 notation or R1C1 notation of the ranges to retrieve values from.\n        - kwargs: Additional query parameters.\n\n        Query Parameters:\n        - majorDimension (enum): The major dimension that results should use.\n        For example, if the spreadsheet data in Sheet1 is: A1=1,B1=2,A2=3,B2=4,\n        then requesting majorDimension='ROWS' returns [[1,2],[3,4]],\n        whereas requesting majorDimension='COLUMNS' returns [[1,3],[2,4]].\n        `I don't prefer to use this parameter. We'll use ROW majorDimension for our proejct which is default.`\n\n        - valueRenderOption (enum): How values should be represented in the output.\n        The default render option is FORMATTED_VALUE.\n        - dateTimeRenderOption (enum): How dates, times, and durations should be represented in the output.\n        This is ignored if valueRenderOption is FORMATTED_VALUE.\n        The default dateTime render option is SERIAL_NUMBER.\n\n        Returns:\n        - dict: A dictionary containing the retrieved values for each range specified.\n\n    \"\"\"\n        return self.__service.spreadsheets().values().batchGet(spreadsheetId=spreadsheetId, ranges=ranges, **kwargs).execute()\n\n    @handle_exception\n    def update_values(self, spreadsheetId, range: str, valueInputOption: valueOption, values: list[list], **kwargs):\n        \"\"\"\n            Updates values in a Google Sheet within the specified range.\n\n            Parameters:\n            - spreadsheetId (str): The ID of the spreadsheet.\n            - range_ (str): The range of cells to update (A1 notation).\n            - valueInputOption (str): How the input data should be interpreted. Possible values are:\n                - \"RAW\": The values will not be parsed and will be stored as-is.\n                - \"USER_ENTERED\": The values will be parsed as if the user typed them into the UI.\n            - values (list[list]): A list of lists containing the new values for the cells.\n            - kwargs: Additional keyword arguments that can be passed to the update method.\n\n            Returns:\n            - dict: A dictionary containing information about the update operation.\n\n            Example:\n            ```python\n            obj = SpreadSheet(k.encode())\n            values = [\n                ['New Value 1'],\n                ['New Value 2'],\n                ['New Value 3']\n            ]\n            obj.update_values(\"spreadsheetId\", \"Sheet1!A1:C3\", 'USER_ENTERED', values)\n            ```\n        \"\"\"\n        body = {\n            'values': values\n        }\n        return self.__service.spreadsheets().values().update(spreadsheetId=spreadsheetId, range=range, valueInputOption=valueInputOption, body=body, **kwargs).execute()\n\n    @handle_exception\n    def batch_update_values(self, spreadsheet_id: str, valueInputOption: valueOption, data: list[dict], **kwargs) -&gt; dict:\n        \"\"\"\n            Updates multiple cells in a Google Sheet using a single batch update API call.\n\n            Parameters:\n            - spreadsheet_id (str): The ID of the spreadsheet.\n            - valueInputOption (str): How the input data should be interpreted. Possible values are:\n                - \"RAW\": The values will not be parsed and will be stored as-is.\n                - \"USER_ENTERED\": The values will be parsed as if the user typed them into the UI.\n            - data (list[dict]): A list of dictionaries containing update details.\n                - Each dictionary should have keys:\n                    - 'range' (str): The range of the cell to update (A1 notation).\n                    - 'values' (list[list]): A list containing the new value for the cell.\n\n            Returns:\n            - dict: A dictionary containing the response from the batch update.\n\n            Example:\n            ```python\n            data = [\n                {'range': 'D15', 'values': [[2225]},\n                {'range': 'F17:G17', 'values': [['Lorem test', ipsum]]},\n                {'range': 'D17:E17', 'values': [['Lorem test', ipsum]]},\n            ]\n            obj = SpreadSheet(k.encode())\n            obj.batch_update_values(\"spreadsheetId\", 'USER_ENTERED', data)\n            ```\n        \"\"\"\n\n        body = {\"data\": data, 'valueInputOption': valueInputOption}\n\n        res = self.__service.spreadsheets().values().batchUpdate(\n            spreadsheetId=spreadsheet_id, body=body, **kwargs).execute()\n        return res\n\n    @handle_exception\n    def append_data(self, spreadsheetId: str, range: str, valueInputOption: valueOption, values: list[list], **kwargs) -&gt; dict:\n        \"\"\"\n            Appends values to a Google Sheet starting from the specified range.\n\n            Parameters:\n            - spreadsheetId (str): The ID of the spreadsheet.\n            - range_ (str): The range of cells to append the values to (A1 notation).\n            - valueInputOption (str): How the input data should be interpreted. Possible values are:\n                - \"RAW\": The values will not be parsed and will be stored as-is.\n                - \"USER_ENTERED\": The values will be parsed as if the user typed them into the UI.\n            - values (list[list]): A list of lists containing the new values to append.\n            - kwargs: Additional keyword arguments that can be passed to the append method.\n\n            Returns:\n            - dict: A dictionary containing information about the append operation.\n\n            Example:\n            ```python\n            obj = SpreadSheet(k.encode())\n            values = [\n                ['New Value 1'],\n                ['New Value 2'],\n                ['New Value 3']\n            ]\n            obj.append_data(\"spreadsheetId\", \"Sheet1!A1:C3\", 'USER_ENTERED', values)\n            ```\n        \"\"\"\n        body = {'values': values}\n        res = self.__service.spreadsheets().values().append(\n            spreadsheetId=spreadsheetId, range=range, valueInputOption=valueInputOption, body=body, **kwargs).execute()\n        return res\n</code></pre>"},{"location":"spreadsheet/#red_office_google_integration.spreadsheets.sheets.SpreadSheet.__build_service","title":"<code>__build_service()</code>","text":"<p>Build and return the Google service.</p> <p>Returns:</p> Type Description <code>cred</code> <p>The Google service.</p> Source code in <code>red_office_google_integration/spreadsheets/sheets.py</code> <pre><code>@handle_exception\ndef __build_service(self):\n    '''\n    Build and return the Google service.\n\n    Returns:\n        (cred): The Google service.\n    '''\n    cred = GoogleCredentialService(self.__key, setting.SCOPE_SPREADSHEETS,\n                                   setting.FILE_NAME_SPREADSHEETS_TOKEN, setting.FILE_NAME_SPREADSHEETS_CREDENTIAL).get_service()\n    return build(\"sheets\", \"v4\",  credentials=cred)\n</code></pre>"},{"location":"spreadsheet/#red_office_google_integration.spreadsheets.sheets.SpreadSheet.__init__","title":"<code>__init__(key)</code>","text":"<p>Initialize the CalendarEvent class.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes</code> <p>The key used for authentication.</p> required Source code in <code>red_office_google_integration/spreadsheets/sheets.py</code> <pre><code>def __init__(self, key: bytes) -&gt; None:\n    '''\n    Initialize the CalendarEvent class.\n\n    Args:\n        key (bytes): The key used for authentication.\n    '''\n    self.__key = key\n    self.__service = self.__build_service()\n</code></pre>"},{"location":"spreadsheet/#red_office_google_integration.spreadsheets.sheets.SpreadSheet.append_data","title":"<code>append_data(spreadsheetId, range, valueInputOption, values, **kwargs)</code>","text":"<p>Appends values to a Google Sheet starting from the specified range.</p> <p>Parameters: - spreadsheetId (str): The ID of the spreadsheet. - range_ (str): The range of cells to append the values to (A1 notation). - valueInputOption (str): How the input data should be interpreted. Possible values are:     - \"RAW\": The values will not be parsed and will be stored as-is.     - \"USER_ENTERED\": The values will be parsed as if the user typed them into the UI. - values (list[list]): A list of lists containing the new values to append. - kwargs: Additional keyword arguments that can be passed to the append method.</p> <p>Returns: - dict: A dictionary containing information about the append operation.</p> <p>Example: <pre><code>obj = SpreadSheet(k.encode())\nvalues = [\n    ['New Value 1'],\n    ['New Value 2'],\n    ['New Value 3']\n]\nobj.append_data(\"spreadsheetId\", \"Sheet1!A1:C3\", 'USER_ENTERED', values)\n</code></pre></p> Source code in <code>red_office_google_integration/spreadsheets/sheets.py</code> <pre><code>@handle_exception\ndef append_data(self, spreadsheetId: str, range: str, valueInputOption: valueOption, values: list[list], **kwargs) -&gt; dict:\n    \"\"\"\n        Appends values to a Google Sheet starting from the specified range.\n\n        Parameters:\n        - spreadsheetId (str): The ID of the spreadsheet.\n        - range_ (str): The range of cells to append the values to (A1 notation).\n        - valueInputOption (str): How the input data should be interpreted. Possible values are:\n            - \"RAW\": The values will not be parsed and will be stored as-is.\n            - \"USER_ENTERED\": The values will be parsed as if the user typed them into the UI.\n        - values (list[list]): A list of lists containing the new values to append.\n        - kwargs: Additional keyword arguments that can be passed to the append method.\n\n        Returns:\n        - dict: A dictionary containing information about the append operation.\n\n        Example:\n        ```python\n        obj = SpreadSheet(k.encode())\n        values = [\n            ['New Value 1'],\n            ['New Value 2'],\n            ['New Value 3']\n        ]\n        obj.append_data(\"spreadsheetId\", \"Sheet1!A1:C3\", 'USER_ENTERED', values)\n        ```\n    \"\"\"\n    body = {'values': values}\n    res = self.__service.spreadsheets().values().append(\n        spreadsheetId=spreadsheetId, range=range, valueInputOption=valueInputOption, body=body, **kwargs).execute()\n    return res\n</code></pre>"},{"location":"spreadsheet/#red_office_google_integration.spreadsheets.sheets.SpreadSheet.batch_update_values","title":"<code>batch_update_values(spreadsheet_id, valueInputOption, data, **kwargs)</code>","text":"<p>Updates multiple cells in a Google Sheet using a single batch update API call.</p> <p>Parameters: - spreadsheet_id (str): The ID of the spreadsheet. - valueInputOption (str): How the input data should be interpreted. Possible values are:     - \"RAW\": The values will not be parsed and will be stored as-is.     - \"USER_ENTERED\": The values will be parsed as if the user typed them into the UI. - data (list[dict]): A list of dictionaries containing update details.     - Each dictionary should have keys:         - 'range' (str): The range of the cell to update (A1 notation).         - 'values' (list[list]): A list containing the new value for the cell.</p> <p>Returns: - dict: A dictionary containing the response from the batch update.</p> <p>Example: <pre><code>data = [\n    {'range': 'D15', 'values': [[2225]},\n    {'range': 'F17:G17', 'values': [['Lorem test', ipsum]]},\n    {'range': 'D17:E17', 'values': [['Lorem test', ipsum]]},\n]\nobj = SpreadSheet(k.encode())\nobj.batch_update_values(\"spreadsheetId\", 'USER_ENTERED', data)\n</code></pre></p> Source code in <code>red_office_google_integration/spreadsheets/sheets.py</code> <pre><code>@handle_exception\ndef batch_update_values(self, spreadsheet_id: str, valueInputOption: valueOption, data: list[dict], **kwargs) -&gt; dict:\n    \"\"\"\n        Updates multiple cells in a Google Sheet using a single batch update API call.\n\n        Parameters:\n        - spreadsheet_id (str): The ID of the spreadsheet.\n        - valueInputOption (str): How the input data should be interpreted. Possible values are:\n            - \"RAW\": The values will not be parsed and will be stored as-is.\n            - \"USER_ENTERED\": The values will be parsed as if the user typed them into the UI.\n        - data (list[dict]): A list of dictionaries containing update details.\n            - Each dictionary should have keys:\n                - 'range' (str): The range of the cell to update (A1 notation).\n                - 'values' (list[list]): A list containing the new value for the cell.\n\n        Returns:\n        - dict: A dictionary containing the response from the batch update.\n\n        Example:\n        ```python\n        data = [\n            {'range': 'D15', 'values': [[2225]},\n            {'range': 'F17:G17', 'values': [['Lorem test', ipsum]]},\n            {'range': 'D17:E17', 'values': [['Lorem test', ipsum]]},\n        ]\n        obj = SpreadSheet(k.encode())\n        obj.batch_update_values(\"spreadsheetId\", 'USER_ENTERED', data)\n        ```\n    \"\"\"\n\n    body = {\"data\": data, 'valueInputOption': valueInputOption}\n\n    res = self.__service.spreadsheets().values().batchUpdate(\n        spreadsheetId=spreadsheet_id, body=body, **kwargs).execute()\n    return res\n</code></pre>"},{"location":"spreadsheet/#red_office_google_integration.spreadsheets.sheets.SpreadSheet.get_batch_data","title":"<code>get_batch_data(spreadsheetId, ranges, **kwargs)</code>","text":"<p>Retrieves data from multiple specified ranges in a Google Sheets spreadsheet.</p> <p>Parameters: - spreadsheetId (str): The ID of the spreadsheet to retrieve data from. - ranges (list[str]): A list of A1 notation or R1C1 notation of the ranges to retrieve values from. - kwargs: Additional query parameters.</p> <p>Query Parameters: - majorDimension (enum): The major dimension that results should use. For example, if the spreadsheet data in Sheet1 is: A1=1,B1=2,A2=3,B2=4, then requesting majorDimension='ROWS' returns [[1,2],[3,4]], whereas requesting majorDimension='COLUMNS' returns [[1,3],[2,4]]. <code>I don't prefer to use this parameter. We'll use ROW majorDimension for our proejct which is default.</code></p> <ul> <li>valueRenderOption (enum): How values should be represented in the output. The default render option is FORMATTED_VALUE.</li> <li>dateTimeRenderOption (enum): How dates, times, and durations should be represented in the output. This is ignored if valueRenderOption is FORMATTED_VALUE. The default dateTime render option is SERIAL_NUMBER.</li> </ul> <p>Returns: - dict: A dictionary containing the retrieved values for each range specified.</p> Source code in <code>red_office_google_integration/spreadsheets/sheets.py</code> <pre><code>@handle_exception\ndef get_batch_data(self, spreadsheetId: str, ranges: list[str], **kwargs) -&gt; dict:\n    \"\"\"\n    Retrieves data from multiple specified ranges in a Google Sheets spreadsheet.\n\n    Parameters:\n    - spreadsheetId (str): The ID of the spreadsheet to retrieve data from.\n    - ranges (list[str]): A list of A1 notation or R1C1 notation of the ranges to retrieve values from.\n    - kwargs: Additional query parameters.\n\n    Query Parameters:\n    - majorDimension (enum): The major dimension that results should use.\n    For example, if the spreadsheet data in Sheet1 is: A1=1,B1=2,A2=3,B2=4,\n    then requesting majorDimension='ROWS' returns [[1,2],[3,4]],\n    whereas requesting majorDimension='COLUMNS' returns [[1,3],[2,4]].\n    `I don't prefer to use this parameter. We'll use ROW majorDimension for our proejct which is default.`\n\n    - valueRenderOption (enum): How values should be represented in the output.\n    The default render option is FORMATTED_VALUE.\n    - dateTimeRenderOption (enum): How dates, times, and durations should be represented in the output.\n    This is ignored if valueRenderOption is FORMATTED_VALUE.\n    The default dateTime render option is SERIAL_NUMBER.\n\n    Returns:\n    - dict: A dictionary containing the retrieved values for each range specified.\n\n\"\"\"\n    return self.__service.spreadsheets().values().batchGet(spreadsheetId=spreadsheetId, ranges=ranges, **kwargs).execute()\n</code></pre>"},{"location":"spreadsheet/#red_office_google_integration.spreadsheets.sheets.SpreadSheet.get_data","title":"<code>get_data(spreadsheetId, range, **kwargs)</code>","text":"<p>Retrieves data from a specified range in a Google Sheets spreadsheet.</p> <p>Parameters: - spreadsheetId (str): The ID of the spreadsheet to retrieve data from. - range (str): The A1 notation or R1C1 notation of the range to retrieve values from. just giving sheet name will return all the data from sheet - kwargs: Additional query parameters.</p> <p>Query Parameters: - majorDimension (enum): The major dimension that results should use. For example, if the spreadsheet data in Sheet1 is: A1=1,B1=2,A2=3,B2=4, then requesting majorDimension='ROWS' returns [[1,2],[3,4]], whereas requesting majorDimension='COLUMNS' returns [[1,3],[2,4]]. <code>I don't prefer to use this parameter. We'll use ROW majorDimension for our proejct which is default.</code></p> <ul> <li>valueRenderOption (enum): How values should be represented in the output. The default render option is FORMATTED_VALUE.</li> <li>dateTimeRenderOption (enum): How dates, times, and durations should be represented in the output. This is ignored if valueRenderOption is FORMATTED_VALUE. The default dateTime render option is SERIAL_NUMBER.</li> </ul> <p>Returns: - dict: A dictionary containing the retrieved values.</p> <p>Raises: - Exception: If there is an error while retrieving the data.</p> Source code in <code>red_office_google_integration/spreadsheets/sheets.py</code> <pre><code>@handle_exception\ndef get_data(self, spreadsheetId: str, range: str, **kwargs):\n    \"\"\"\n    Retrieves data from a specified range in a Google Sheets spreadsheet.\n\n    Parameters:\n    - spreadsheetId (str): The ID of the spreadsheet to retrieve data from.\n    - range (str): The A1 notation or R1C1 notation of the range to retrieve values from. just giving sheet name will return all the data from sheet\n    - kwargs: Additional query parameters.\n\n    Query Parameters:\n    - majorDimension (enum): The major dimension that results should use.\n    For example, if the spreadsheet data in Sheet1 is: A1=1,B1=2,A2=3,B2=4,\n    then requesting majorDimension='ROWS' returns [[1,2],[3,4]],\n    whereas requesting majorDimension='COLUMNS' returns [[1,3],[2,4]].\n    `I don't prefer to use this parameter. We'll use ROW majorDimension for our proejct which is default.`\n\n    - valueRenderOption (enum): How values should be represented in the output.\n    The default render option is FORMATTED_VALUE.\n    - dateTimeRenderOption (enum): How dates, times, and durations should be represented in the output.\n    This is ignored if valueRenderOption is FORMATTED_VALUE.\n    The default dateTime render option is SERIAL_NUMBER.\n\n    Returns:\n    - dict: A dictionary containing the retrieved values.\n\n    Raises:\n    - Exception: If there is an error while retrieving the data.\n\"\"\"\n    return self.__service.spreadsheets().values().get(spreadsheetId=spreadsheetId,\n                                                      range=range, **kwargs).execute()\n</code></pre>"},{"location":"spreadsheet/#red_office_google_integration.spreadsheets.sheets.SpreadSheet.update_values","title":"<code>update_values(spreadsheetId, range, valueInputOption, values, **kwargs)</code>","text":"<p>Updates values in a Google Sheet within the specified range.</p> <p>Parameters: - spreadsheetId (str): The ID of the spreadsheet. - range_ (str): The range of cells to update (A1 notation). - valueInputOption (str): How the input data should be interpreted. Possible values are:     - \"RAW\": The values will not be parsed and will be stored as-is.     - \"USER_ENTERED\": The values will be parsed as if the user typed them into the UI. - values (list[list]): A list of lists containing the new values for the cells. - kwargs: Additional keyword arguments that can be passed to the update method.</p> <p>Returns: - dict: A dictionary containing information about the update operation.</p> <p>Example: <pre><code>obj = SpreadSheet(k.encode())\nvalues = [\n    ['New Value 1'],\n    ['New Value 2'],\n    ['New Value 3']\n]\nobj.update_values(\"spreadsheetId\", \"Sheet1!A1:C3\", 'USER_ENTERED', values)\n</code></pre></p> Source code in <code>red_office_google_integration/spreadsheets/sheets.py</code> <pre><code>@handle_exception\ndef update_values(self, spreadsheetId, range: str, valueInputOption: valueOption, values: list[list], **kwargs):\n    \"\"\"\n        Updates values in a Google Sheet within the specified range.\n\n        Parameters:\n        - spreadsheetId (str): The ID of the spreadsheet.\n        - range_ (str): The range of cells to update (A1 notation).\n        - valueInputOption (str): How the input data should be interpreted. Possible values are:\n            - \"RAW\": The values will not be parsed and will be stored as-is.\n            - \"USER_ENTERED\": The values will be parsed as if the user typed them into the UI.\n        - values (list[list]): A list of lists containing the new values for the cells.\n        - kwargs: Additional keyword arguments that can be passed to the update method.\n\n        Returns:\n        - dict: A dictionary containing information about the update operation.\n\n        Example:\n        ```python\n        obj = SpreadSheet(k.encode())\n        values = [\n            ['New Value 1'],\n            ['New Value 2'],\n            ['New Value 3']\n        ]\n        obj.update_values(\"spreadsheetId\", \"Sheet1!A1:C3\", 'USER_ENTERED', values)\n        ```\n    \"\"\"\n    body = {\n        'values': values\n    }\n    return self.__service.spreadsheets().values().update(spreadsheetId=spreadsheetId, range=range, valueInputOption=valueInputOption, body=body, **kwargs).execute()\n</code></pre>"}]}